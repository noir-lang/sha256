{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":98857430389504108,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":200,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9WdB3gc1bXHZ3ZXq2LLki13UhSSl5e8JC8rVzntCRIg9J7QQZYlMNjYGJlelt5777333nvvvfdOIJRAAimUN8fMlf46OmdmtLMDnPm++aTd/d17/rffuW1876vr7eD2w/9rwr+58C99f7c38HJsR/i3lO5qq6Jfpaw0+gY05gxozBvQWDCgscaAxqIBjbUGNNYZ0FhvQGODAY3DDGgcbkBjowGNIwxobDKgsdmAxpEGNI4yoLHFgMbRBjSOMaBxrAGN4wxoHG9A4wQDGica0LiYAY3fMaDxuwY0fs+Axu8b0NhqQOMPDGhc3IDGHxrQ+CMDGv/LgMYfG9D43wY0/sSAxp8a0Pg/BjT+zIDGnxvQ+AsDGv/XgMZfGtBYMqCxzYDGSQY0TjagcYoBjVMNaJxmQON0AxrbDWicYUDjrwxo/LUBjb8xoPG3BjT+zoDG/zOgscOAxiUMaFzSgMbfG9D4BwMalzKgcWkDGpcxoPGPBjQua0DjcgY0Lm9A4woGNK5oQONKBjSubEDjKgY0rmpA42oGNK5uQOMaBjSuaUDjnwxo/LMBjWsZ0Li2AY3rGNC4rgGN6xnQuL4BjRsY0LihAY0bGdDYaUDjTAMauwxonGVAY7cBjT0GNG5sQOMmBjTONqBxUwMaNzOgcY4BjXMNaNzcgMZ5BjTON6BxCwMaFxjQuKUBjb0GNC40oHErAxq3NqBxGwMatzWgcTsDGrc3oHEHAxp3NKBxJwMadzagsWxA4y4GNO5qQONuBjTubkDjHgY07mlA414GNO5tQOM+BjTua0DjfgY07m9A4wEGNB5oQONBBjQebEDjIQY0HmpA42EGNB5uQOMRBjQeaUDjUQY0Hm1A4zEGNB5rQONxBjQeb0DjCQY0nmhA40kGNJ5sQOMpBjSeakDjaQY0nm5A4xkGNJ5pQONZBjSebUDjOQY0nmtA43kGNJ5vQOMFBjReaEDjRQY0XmxA4yUGNF5qQONlBjRebkDjFQY0XmlA41UGNF5tQOM1BjRea0DjdQY0Xm9A4w0GNN5oQONNBjTebEDjLQY03mpA420GNN5uQOMdBjTeaUDjXRlozELn3VXU6YPG1vD/e4L73uC+L7jvD+4HgvvB4H4ouB8O7keC+9Hgfiy4Hw/uJ4L7yeB+KrifDu5ngvvZ4H4uuJ8P7heC+8Xgfim4Xw7uV4L71eB+LbhfD+43gvvN4H4ruN/2QARGYC6488FNL6SnF77TC9XpheX0QnB64Ta90JpeGE0vZKYXHtMLhemFvc3BTS+cpRe60gtT6YWk9MJPeqEmvbCSXghJL1ykFxrSCwPphXz0wjt6odz3w0j5QXAvHtz0wix6IRW98IleqEQvLKIXAtELd+iFNvTCGHohC73whF4oQi/soJxAL5ygFzrQCxPohQR04D8dqE8H1tOB8HTgOh1oTgeG04HcdOA1HSjtDmxeIriXDG46MJcOpKUDX+lAVTqwlA4EpQM36UBLOjCSDmSkAw/pQEE6sG+V4KYD5+hANzowjQ4kowO/6EAtOrCKDoSiA5foQCM6MIgO5KEDb+hAGTqwZaPg7gzumcFNB2bQgRR04AMdqEAHFtCBALThnja004Zx2pBNG55pQzFt2J0f3LThlDZ00oZJ2pBIG/5oQx1tWKMNYbThijY00YYh2pBDG15oQwlt2CgH9y7BvWtw04J5WpBOC75pQTUtWKYFwbTglha00oJRWpBJCx5pQSEt2Ds4uGnBGS3oogVTtCCJFvzQghpasEILQmjBBS1ooAUDNCFPE940oUwTticH9ynBTRN6NGFGE1I04UMTKjRhQRMCNOBOA9o0YEwDsjTgSQOKNGBHA2I04EQDOjRgQgMS9MBPD9T0wEoPhPTARQ809MBAHXLq8FKHkjpsNwc3dTioQacGkxokqvCpQqUKiyoDd7WGf7/pArxkqMMHbSvChx+Efzt7e7vnzu9t7Z3XuuXCmb0LOrt6W7ee3btJ67ytuhf0zJm3NXrQBR++M9iDzlmzdLd7wYcJ4d8lFizo3LZ19uazurdpnbewt3VeT+vMeQs3n7UlOjw0reoToj2Yu3BO7+z5c7bVPTgvrQcXwYfFB3swc3bvL7bcZHZPRBiuSxsJd6YNw32pw/BQitzzWKW5580URsfmIuMsPtK/m6tQ9U+iLcen1pS0HrSDB5Uld0elgV8WHA41ydZLG+4zK1V9QwrVd6dVfX8K4w9XGuKnKnX4Wgq176WNqo9SGP+k0hB/nsKon6/QaF2+cqPDKzXaksLouEqN/iSF0akp3C6Zwu3SlQZ2tRRG167U6KwURhdWarScwuh+4LaieuKgFMaPTuH2+Epj66IURi9P4fbGtDF9dwrjj0cbj++ivZPC+GKFyt3+DNwOKZmnpTC6RCEytuKTaqkUxldK4Xa1SmOrO4XRTVO4nQ9uR4R/V+/t7NoscDmvdVZ39/y+J/NjQ7Q+/Oy6CvQ7Zc6O8HMp3dVWD/5W2//2tkld9d7Aq8r6J9eDn9X3v2uG87+Qjf5SbejP78sD/feY3TzjuBt09wdg/qAwSwGzlMIsDczSCrMMMMsozB+B+aPCLAvMsgqzHDDLKczywCyvMCsAs4LCrAjMigqzEjArKczKwKysMKsAs4rCrArMqgqzGjCrKczqwKyuMGsAs4bCrAnMmgrzJ2D+pDB/BubPCrMWMGspzNrArK0w6wCzjsKsC8y6CrMeMOspzPrArK8wGwCzgcJsCMyGCrMRMBspTCcwnQozE5iZCtMFTJfCzAJmlsJ0A9OtMD3A9CjMxsBsrDCbALOJwswGZrbCbArMpgqzGTCbKcwcYOYozFxg5irM5sBsrjDzgJmnMPOBma8wWwCzhcIsAGaBwmwJzJYK0wtMr8IsBGahwmwFzFYKszUwWyvMNsBsozDbArOtwmwHzHYKsz0w2yvMDsDsoDA7ArOjwuwEzE4KszMwOytMGZiywuwCzC4KsyswuyrMbsDspjC7A7O7wuwBzB4KsycweyrMXsDspTB7A7O3wuwDzD4Ksy8w+yrMfsDspzD7A7O/whwAzAEKcyAwByrMQcAcpDAHA3OwwhwCzCEKcygwhyrMYcAcpjCHA3O4whwBzBEKcyQwRyrMUcAcpTBHA3O0whwDzDEKcywwxyrMccAcpzDHA3O8wpwAzAkKcyIwJyrMScCcpDAnA3OywpwCzCkKcyowpyrMacCcpjCnA3O6wpwBzBkKcyYwZyrMWcCcpTBnA3O2wpwDzDkKcy4w5yrMecCcpzDnA3O+wlwAzAUKcyEwFyrMRcBcpDAXA3OxwlwCzCUKcykwlyrMZcBcpjCXA3O5wlwBzBUKcyUwVyrMVcBcpTBXA3O1wlwDzDUKcy0w1yrMdcBcpzDXA3O9wtwAzA0KcyMwNyrMTcDcpDA3A3OzwtwCzC0KcyswtyrMbcDcpjC3A3O7wtwBzB0KcycwdyrMXcDcpTB3A3O3wtwDzD0Kcy8w9yrMfcDcpzD3A3O/wjwAzAMK8yAwDyrMQ8A8pDAPA/OwwjwCzCMK8ygwjyrMY8A8pjCPA/O4wjwBzBMK8yQwTyrMU8A8pTBPA/O0wjwDzDMK8ywwzyrMc8A8pzDPA/O8wrwAzAsK8yIwLyrMS8C8pDAvA/OywrwCzCsK8yowryrMa8C8pjCvA/O6wrwBzBsK8yYwbyrMW8C8pTBvA/O2wvwFmL8ozDvAvKMw7wLzrsL8FZi/Ksx7wLynMO8D877CfADMBwrzITAfKszfgPmbwnwEzEcK8zEwHyvM34H5u8L8A5h/KMwnwHyiMJ8C86nC/BOYfyrMv4D5l8L8G5h/K8x/gPmPwnwGzGcK8zkwnyvMF8B8oTBfAvOlwixaBs7+54wPjK8wOWByCpMHJq8wBWAKClMDTI3CFIEpKkwtMLUKUwdMncLUA1OvMA3ANCjMMGCGAUPziPXAe+CuI/xcSnG1l6ZMznautKu9kYXVg7A42zXZ2J7hM3se6MDfnP0GprW6ekptPrPn9PD4cesGGh1T7tfjs98K5cHhcL/VwG8ufWmHzxvASXkLf4Pljn15k/z40BuoKSeEyRfClOXcf3tbqSvb/DypJKUJT69CeaBt/C0uTWhX1fAwnlshzuiqLWcRpv5ta3Wh/zWg29lE7TnG8/9r2HcfeP26F4UH2L42Ar5zNpvCz0X4zbmN8qsg+NUs8EXmV63gF37nwk275d4M/6ddcpR+cwv97nidxtcBOQbzKPIFYHLse/SnkX3vflsUTi/LurWtrdK6NaM1OZF1K8YPr4eK2egpOf9rs4n/ks/8x/DWCvHv8kqd8Jvzy9UzNeAX8rUQh8jj/849fpcPM0Sz4GeRaagTwoPfYRn8PPy/yZPLEPor5Ysawd9mTy+bjYI7X/nr7PDvuB1Jc1Z5Z+rM7lLXrLa+9XF11fa/rdQ9ddL0Hud/fZX9nzlz2vTO7vapzv+GKvvf1tM+edaMzpnO/2FV9r9z6pSenqmTO53/w6vs/7TO0ozuadOmu3zq+hzOBuatEVW2HV6J+9zOfgPTmlW7MILp4fGDfTj6rUnQ2iz8hmmIv6GdJsGO5Fd9hX65NG0G99WIw8ld07p7Jk+fJGltrmK4h1XRr7oK/XJxOBLcVyMOZ8wsTZ3W3t4laR1ZxXA3VNEv1+64dhXrikZmRypXIyLsoHvHNQru0rarkuZGFr5q2ME22vVlsmpfw6tNal/96vnfnlX7Gl6Ts2pfw2uK1L5WMX76+vbZtFlTSnzMDPMW/Z3uDwyXK7vYb0e3DfA78lfl+/38Vehnkze4PuB96aHWLejecY2Cu7RlUdKc6XhQW6nvOcy1h5gGuQg91W5nvrq6SjVMzzJhhFEaL+UPjHuMU5eXiVuD5a9RMWEbCb8jvwrYXk7x04/x0/EtoC8vMDmmwfErhXadPX65uMD+zCiwtZqvc8UIDuO2GTget+43HBdCt8OYTgxH2vIyStDo8udo+K2adbML95iYcKN9usdCGPLMD4lvYfq5/2MZ79zj2Bv6UQT7/Dfnli6e/zaCMtDjyxo9sIn5q07RWFT4FqbB8bNiyoCUH7C89bC2AcPu3MSVj9kJ6pSosDh+E2iz5jBdPrjHtgA/o72o+sPx8yH9Fka0kb5iz/OStZGSdmmMyHGox2e/JQ2j47eBMG7nD7TNx6A4J8V9LdPbNy7vDZ4bor99cyOM3wl0lSN0YT4rM11Y5l08NjG76J+Utjw8Up2Nfrk6O9u2vn8MOK4sae3z3jH1gs/ce97gupSuHONHCTzGgdMmpYNzW+8NrpOyaIdaQCcvp9w+1qnYDrVE8Dztuf+jlbhDHp+Thtovcm55u3RYTNonCZtkj7e7ecEtDwOPqxx8Vy/Yl/oodHeEn0spLx63BW9w+vNyh/yJrF4ey+KUxwGP1zGCXeyv1DO7Y5jduPLsdA7z5PqLp0/fvLYX3TeqV9x3hJ9Lqa5JJSndPa964yo1LLyXQvtzui/HSdK8OjaTOOnPq3F5hudVx5/PwjU+/D4vhFXKq+MEu+OB4Xl1HLMbl1fd7w2enPf4eCTvN2p5m5fZi2P0SGtl8Dnxcl/nigL3bW3fXL5I2r7xMTDu/xjGNwk8jjPy9MQ4luoqPrbl+Otj0lNql3h/XrLH00sKMw9D0jrD+eHyRgvzpyP8XEp58bjFstsi6OFxexerM6T2rdHT47XS9u2umDSt9+Q81uFVI97aS1F1UlT683iMq5Mcf3/COhLnMaXnq1GKnqKX7HnM8Q9/o/Gf/HlHy7ePJ6jj6cK1fXkIG12FciZha6OxngWFfh2YJovCAnYxjJ43OA3pSvJMJs3nSmNBLl6k57U8syO1B9I8e7PgntvhfuP/eSE8+Qg7vqA5anxF0lCrhFXSQP9rc9FFhdfK3Vsx+VYaE/m64zLbM70mt0t16VDi8INQdBECJMUNn5OOWkOTTT2XfA2Ns/91raFJWudktR4llFOKqtPyEXpaMtFTauf9GtQj1X0jPXnOUpqD4rqdDVe3SHmY9z+GWr6l+j1qXUXcmGxUeXNusl6b4TM7jVW0I8XX1zVHkG1Z63+OHAU6pXqXrwdrgTBIz1ra+jFf8Z8/Czn3BU/uz/D5Osk2XbyPOCqMdHK/Qm6gzbg4GKbEAYYJGe25qKiEiY/lOn5cqDPuWRefxXl8xj27Y5hbIsIgjXdlUfePg7iQ8tdYFleO/15MXPnMPcafVAdwPchL42+uXsC4HafY1sYJXPy7uB7P3HeEn0spLx42bYyPj7k5/qes/Exk8cPjiOfJCYLdicDwcYIJzG5cGjudOA6O6cLHbHHcIu8NTrsi0+P4X0Od8ouc7Oe3Ja3HQhiTpLXjpyZI66j6p9K0npowrZ09HLPBtOPjlLz+4MxIJR5mxOiR1kngHN5vczpXFLhs+7b99e1oCK9U32prT5YYYvp4XrL6drTAS+PUzYzHOHVxzOer0B32ITnXLGjA/gBvG5177fkf1xAiv1xMHEr9UFxztgLrf0eNVfaNgXnRfZCMn4G749YorpqTdWvjAnxM0PFr5vv9XIOVqYyep9t5/sE+Mtrkz68ZzRWVeP7E9m2UoIfnz/VZWriyhnmoWfCHl320i+WVj+m0MLtx/V60h2W2UfjOlf9s1+4kH+Nx9hu8wfGYxRiPtNYH4wfHMEYK8VsQtPft38w4I7dLA/hOhLQ5fxQI3KswUGMuG42T4hb3b8YKE3Y0pIpNK5RvQqdz8wQDME3e4AbPZ//zxYD4nedFD1hwOz7zC+3wQqF1BpoV9/hbjWBH0sAHfquxyTdqUCurTbJhNku8Qd/Zb/DkNO6oip7+Cqae6dHyULabkCb1NXoNgp4GIX74JjWedryTkRf4Bggj8vi/c4/f7RVGijQIyzc5Jd2QR/XCLqxewPDwekBKt3rBX6njzOMQ3VVatpojNCcpdxltbkvcsDv7X1e5k/J51GRJtTenh3JKUfnUj9CT0YPGoM446pHqJZy8wTyE8YXlU5rg4ZM3UjtZaVsotd9SW8jLCvZ3sD9yQk7Wo20G4511x58K/ZGTWb0jtUfDvOhF/BmX47584dJVCy9fgOb4sxIOfCQtl1wP8hgHjpf6c8MVOzyvf4P151RL9adWP4z0BsdvQdDedzBRtpVuaYr0YORESA9GTgc+GMWtbL2KVRQu8Fhw0C2fzXL8zVBRXKtUPp4nF0a+4iYP+iTeVzTcmHAUV/ILK02pAuOdRuwUSrOEvCHM6OSWEq9gcDRmhKCHV3j3sLSSdklJFZXjmwS7ONrB80sTsxtX0cZVnD7734W5qPDDmR7HPxCjJ+N0nMLjUyt/I5h+xz+SMD6lDpxUIXI9yI9gjOf1lxmMa77aIZvO4KTI3fzDBT18t/3TCeqNReEvD9TvwkZXoZxJ2MQVppiGNWA3Lr3o4ukrdaAxnVz8NXuDy3YD+w3rSJ5H8oIdzNe8DXB+a6udsZ1C/vWEbYDkl9QeOn+wnsd2gc+sZLQDX9zdJo26azsH32fhwtX/0qwBXxUjzaLz1SJodwyzq6WHtDudPwxJs4a8LpG0aityRitaP07YBmSzSqb/4aXSVTKfplglI80WcD3Ip10l4ylhq1NsF72hxcUXCdMSV0lkkZYTQJ8Ud+OZfsfn8tH6febe85Kl5QSBxzhw2lxaYvpNYH7FpWVO0Zo0LR1fHxMX9YK+LNJyIuiT0nIC0+/4xoRpKaVNVFpOFHiMA56WmM4TmV9xadmgaE2alo4fbTwtx39L0hLjmq/awnDw1aBJ23NtVdziYfjp9+/nB4bBMQ2Kn3xCYaSgk/z9UV7nigIn2RqnhFtqy9B/vnpQyucjBTuDVjMmzCfS6o2o1YmO/yWkw8/zsp/aqjmeDtIKOfK3La9zRYGLat+SpEPUKk6p7ZD6GbztmJYwHSpdJfobSIcZCcpDVDpo5eF3CcvD71g6YPxIJ5Tg9+hO0sHbCa088BMLHP/7hPU+r686ws+lVFfboJWyWO+PFsLL9S8To18aI8BVwHQVypmETRwjwBVBNWAXw+h5g9OQLt42SX0D6RS3Zm9w2eUrOqNWZkadWET/82cD6ZSBvOA/3y2yeoK01PzCxT5RJ1J9k6dIJYmDdSrIz40QNroK5UzCJubnAbt/wK6Wb6L6WnF1nos/aVc1f/PBUHcTx60m5hOxju+OSS+pfPEV05IdXJXrOBxv8ZW/HvPPXXxiG+vWItMjxSv9nau0o9p4iLbDandom+eH/0v9Zzc2JI1fOP3f5A4pHHPVxju2qqA842lHdBXKmYRNLM8DTt8Eu1p7g/xQx6f4KQlRO0ikuiHqdE9prFHaEczz5i4Jy7M0btkYYUc6tVM6hVWao8t4TEzcmSaNQfHy7Pj9Wb2Az71SuvMx7AmCXRwH4Ts5JjC7SXemeV70OKnPwlz0op9h+TPNwQn1SH1d/lyM/jv+CKg3D4t4BhwO+k/Ny7Y9L/q5OSoupOdyHhfHJHyuyCZPd6Ue5z0hxTivD99lMc4rpTmOx5+a1/0YrehP+nzt+HMgL56Zl/1M+nwtpQf5e15e54oCJ9mKG2dDd9o4VZI6gT+fOv7ihO3JaEWzpjVqbkYaCxgVodXxVyR8/pL8kvqHcTuyXD33bdmRxetdx9/EwhW3Iwv733RXuiPrppj0aPIG18f87RLSM5g0piC9XQI3+3B3vvLX2eHfcTtRmuP6etoplUn7eo6/J2Edj7txnf+5BP4/CHXk/awuk3aNEvdcfmi2mxXbT4HtRxQ//Rg/eX7X4pevYXP8ExXUJ5iWz+R1rhjBSSdySnErnUAi7c5tZNrc79Jf5x//jud/aXd1tmOt/WvZxsaEm7c/4yAMUW0fzy++4j9vW6Uxfml8IufpbSVdPP+9BWXgPaUO97xkbar0PIm8tnbl3YTtv/QGDNTd5A0Ou3MTVz4+TFCnRIXF8d8r9Pv5ccS4jTZ+rI2daJsuP4X0+4zZizrxe6htnqRd2uSBdcln+eqE8UsIo18YaBvHDPG0Q8f57Lc4203Cb3xNl9RHimp7sY/HtfJ4Qb4W8tL4wkB96L4mQjvfZCr1TzLuWybeoIan3PL8W0U9bbxtc3owXuni6+C/rhNPUE9zhJ6M2sB23gaiHqmOwA1q2imC2rObs8E3qEnlg5dl1BV1ih2652+6GSHYwfIWZTNqrgRPQ5F4bT33d0K7Q5nfw3rPvamPj384Vvrrecn6Y9IaCt7v4+3qD1k8SuN66JaPnzr+V1AX/pjVhejepWETc4/6Xfnh44kd4edSqqu/PI8XworlQxsj/XmCPEDXt2W+fkD/EuxiGD1v8Pw7Xdo6S+QxnficvDQu6LM4Qb/SjAlpJ5FNj0kvqR5ycRD3fMf7pdJzhjSfmPFaxEF5HPtCEwQ9PI8vyeqFxcLv8XlrnOCP4ycKdhcDho83TGR2KxmzRj3aaXJFhdfG0JdOqEeaW8W8z9sTxy8P9eayrNxiecH5kLUKsm3Pk/u7/IRAKS6Q19YdrhwTF9nm6a7I9bXSHAPPW6snTEtpfkNqd7ke5DEOnLaotdJx8whrFXQ/xij6tTlQPh/i+A0hL65XkP1sUPzk8yFSepC/nQWdKwpc1PyS7w1MH6k/LJXxpHWCts68J2F7ErXmVNKKdVaSvSotEVodv1nC/qrkF/YPs+y3TG//qr1aFBfl/nDkBb0F+B35LWLC6Q6PWBSucv/32Eejqzb87MoO53EMBPmtoOxsA3l8ESvYI27PCM5X/i7yQ/iuELp16VRf7meq3a+gq6HcHw95ZhP15BjP/69h3+0O9Q5dw8qDw52H75xNl7Z18NuwcrxfNYJfzQJfx/yqF/zC7/BQpe3DMDUwm1VOmzbMU5TfXV4oZmNvks/C4/qGdBXKfVHRZ7+RxSVy35Z868Iy1Hx7DMu3dSwc+B36X2k+xzopST5Hv+qYX7Up/IoqM7UV6pL8KjK/hlL+9oMy8f/5Lh/aiUgBAA==","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"70":{"source":"use std::runtime::is_unconstrained;\nuse std::hash::sha256_compression;\n\n/// Block size\nglobal BLOCK_SIZE: u32 = 64;\n\n/// First index in the block where the 8-byte message will be written.\nglobal MSG_LEN_PTR: u32 = 56;\n\n/// Size of message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n/// Size of unsigned 32 bit integer in bytes.\nglobal INT_SIZE: u32 = 4;\n\n/// Index of the integer in `INT_BLOCK` where the length is writen.\nglobal INT_SIZE_PTR: u32 = MSG_LEN_PTR / INT_SIZE;\n\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n/// Index of abyte in 64 byte block;\ntype BlockBytePtr = u32;\n\n/// Foreign function interface type\npub(crate) type IntBlock = [u32; INT_BLOCK_SIZE];\n\ntype MsgBlock = IntBlock;\n\ntype Hash = [u8; 32];\n\ntype State = [u32; 8];\n\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> Hash {\n    sha256_var(msg, N as u64)\n}\n\n/// SHA256 hash function\npub fn sha256_var<let N: u32>(msg: [u8; N], msg_len: u64) -> Hash {\n    let msg_len = msg_len as u32;\n\n    let num_blocks = N / BLOCK_SIZE;\n\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let mut state: State = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\n        0x5be0cd19,\n    ];\n\n    let mut msg_byte_ptr = 0;\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        if (msg_start < msg_len) & (msg_byte_ptr == BLOCK_SIZE) {\n            state = sha256_compression(msg_block, state);\n        }\n    }\n\n    let modulus = N % BLOCK_SIZE;\n\n    if modulus != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n\n    msg_byte_ptr += 1;\n\n    let last_block = msg_block;\n\n    if msg_byte_ptr > MSG_LEN_PTR {\n        state = sha256_compression(msg_block, state);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, msg_len) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, msg_len);\n    }\n\n    hash_final_block(msg_block, state)\n}\n\nunconstrained pub(crate) fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_start: u32,\n) -> (MsgBlock, BlockBytePtr) {\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let block_input = if msg_start + BLOCK_SIZE > msg_len {\n        if msg_len < msg_start {\n            0\n        } else {\n            msg_len - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    let mut int_input = block_input / INT_SIZE;\n\n    if block_input % INT_SIZE != 0 {\n        int_input += 1;\n    }\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n\n            msg_item = shl8(msg_item, 1) + msg_byte as u32;\n        }\n\n        msg_block[i] = msg_item;\n    }\n\n    (msg_block, block_input)\n}\n\npub(crate) fn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_block: MsgBlock,\n    msg_start: u32,\n) -> BlockBytePtr {\n    let mut msg_byte_ptr = 0;\n\n    let mut msg_end = msg_start + BLOCK_SIZE;\n\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    if msg_end % INT_SIZE != 0 {\n        msg_end += INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    let mut msg_item: u32 = 0;\n\n    let mut i: u32 = 0;\n\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            if (msg_start < msg_len) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n\n                i += 1;\n\n                msg_item = 0;\n            }\n        }\n\n        msg_item = shl8(msg_item, 1);\n\n        if k < msg_len & k < msg_end {\n            msg_item += msg[k] as u32;\n\n            msg_byte_ptr += 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\npub(crate) fn verify_msg_block_padding(msg_block: MsgBlock, msg_byte_ptr: BlockBytePtr) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\npub(crate) fn verify_msg_block_zeros(\n    msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    max_int_byte_ptr: u32,\n) {\n    let zero = msg_block[0] - msg_block[0];\n\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let zeros = INT_SIZE - modulus;\n\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n\n        int_byte_ptr += 1;\n    }\n\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\npub(crate) fn verify_msg_block_equals_last(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n) {\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let last_field = last_block[int_byte_ptr];\n\n        let mut msg_item: u32 = 0;\n\n        msg_byte_ptr -= modulus;\n\n        for i in 0..INT_SIZE {\n            msg_item = shl8(msg_item, 1);\n\n            if i < modulus {\n                msg_item += get_item_byte(last_field, msg_byte_ptr) as u32;\n\n                msg_byte_ptr += 1;\n            }\n        }\n\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\npub(crate) fn update_block_item<Env>(\n    mut msg_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    f: fn[Env](u32) -> u32,\n) -> MsgBlock {\n    let i = msg_byte_ptr / INT_SIZE;\n\n    msg_block[i] = f(msg_block[i]);\n\n    msg_block\n}\n\npub(crate) fn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BlockBytePtr, msg_byte: u8) -> u32 {\n    let zeros = (INT_SIZE - msg_byte_ptr % INT_SIZE) as u8;\n\n    let zeroed_item = shl8(shr8(msg_item, zeros), zeros);\n\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n\n    zeroed_item + new_item\n}\n\npub(crate) fn get_item_byte(mut msg_item: u32, msg_byte_ptr: BlockBytePtr) -> u8 {\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    msg_item = shr8(msg_item, shifts);\n\n    msg_item as u8\n}\n\npub(crate) fn byte_into_item(msg_byte: u8, msg_byte_ptr: BlockBytePtr) -> u32 {\n    let mut msg_item = msg_byte as u32;\n\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    shl8(msg_item, shifts)\n}\n\npub(crate) fn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = shl8(item, 1) + b1 as u32;\n    item = shl8(item, 1) + b2 as u32;\n    item = shl8(item, 1) + b3 as u32;\n\n    item\n}\n\npub(crate) fn shl8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\npub(crate) fn shr8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\nunconstrained pub(crate) fn attach_len_to_msg_block(\n    mut msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) -> MsgBlock {\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let i = msg_byte_ptr / INT_SIZE;\n\n        let zeros = (INT_SIZE - modulus) as u8;\n\n        msg_block[i] = shl8(shr8(msg_block[i], zeros), zeros);\n\n        msg_byte_ptr += zeros as u32;\n    }\n\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * msg_len;\n\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n\n    for i in 0..=1 {\n        let shift = i * 4;\n\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n\n    msg_block\n}\n\npub(crate) fn verify_msg_len(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    let mut reconstructed_len: u64 = 0;\n\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len *= TWO_POW_32;\n\n        reconstructed_len += msg_block[i] as u64;\n    }\n\n    let len = 8 * msg_len as u64;\n\n    assert_eq(reconstructed_len, len);\n}\n\npub(crate) fn hash_final_block(msg_block: MsgBlock, mut state: State) -> Hash {\n    let mut out_state: Hash = [0; 32];\n\n    state = sha256_compression(msg_block, state);\n\n    for j in 0..8 {\n        let state_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n\n        for k in 0..4 {\n            out_state[4 * j + k] = state_bytes[k];\n        }\n    }\n\n    out_state\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/sha256.nr"},"71":{"source":"use crate::sha256::{\n    attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n    set_item_byte_then_zeros, sha256_var, IntBlock, shl8, shr8,\n};\n\n#[test]\n#[export]\nfn test_sha256_0() -> [u8; 32] {\n    sha256_var([], 0)\n}\n\n#[test]\n#[export]\nfn test_sha256_1(input: [u8; 1], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_200(input: [u8; 200], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_511(input: [u8; 511], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_512(input: [u8; 512], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\nfn test_smoke() {\n    let input = [0xbd];\n\n    let result = [\n        0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05,\n        0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe,\n        0x73, 0x2b,\n    ];\n\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    let result = [\n        91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24,\n        65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_multiple_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n    ];\n    let result = [\n        116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60,\n        47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_under_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59,\n    ];\n    let result = [\n        143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165,\n        74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_not_block_multiple() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115,\n        97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n    ];\n    let result = [\n        112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55,\n        192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_with_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    let message_size = 297;\n    assert_eq(sha256_var(input, message_size), result);\n}\n\n#[test]\nfn msg_big_no_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn test_get_item_byte() {\n    let fld = make_item(10, 20, 30, 40);\n    assert_eq(fld, 0x0a141e28);\n    assert_eq(get_item_byte(fld, 0), 10);\n    assert_eq(get_item_byte(fld, 4), 10);\n    assert_eq(get_item_byte(fld, 6), 30);\n}\n\n#[test]\nfn test_byte_into_item() {\n    let fld = make_item(0, 20, 0, 0);\n    assert_eq(byte_into_item(20, 1), fld);\n    assert_eq(byte_into_item(20, 5), fld);\n}\n\n#[test]\nfn test_set_item_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 0, 0, 0);\n    assert_eq(shl8(shr8(fld0, 3), 3), fld1);\n    assert_eq(shl8(shr8(fld0, 4), 4), 0);\n    assert_eq(shl8(shr8(0, 4), 4), 0);\n}\n\n#[test]\nfn test_set_item_byte_then_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 50, 0, 0);\n    assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n}\n\n#[test]\nfn test_build_msg_block_start_0() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48,\n    ];\n    assert_eq(input.len(), 22);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n    assert_eq(msg_byte_ptr, input.len());\n    assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n    assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n    assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n    assert_eq(msg_block[6], 0);\n}\n\n#[test]\nfn test_build_msg_block_start_1() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    assert_eq(input.len(), 68);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n    assert_eq(msg_byte_ptr, 4);\n    assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n    assert_eq(msg_block[1], 0);\n}\n\n#[test]\nfn test_attach_len_to_msg_block() {\n    let input: IntBlock = [\n        2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n        1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n        1849316213, 1651139939,\n    ];\n    let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n    assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n    assert_eq(msg_block[1], 0);\n    assert_eq(msg_block[15], 3584);\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/tests.nr"}},"names":["test_sha256_200"],"brillig_names":["test_sha256_200"]}