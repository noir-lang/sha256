{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":17066098484950826306,"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"5dvNaoNAFAXgd5m1i/H+ONFXKSVoomFANKgpFPHdO2lNI03pprQMnJ2jl8s5m+HbOJtjXV1Oe981/WiKp9m0/aGcfN+F02zs+6vxXHbX0ziVw2QKYk1M3R3Dk9KSmMa3tSlcuiQPo0ycrbNMOd+H7fKcmPRPt9Nvt4vd3baL0Hb743BqM2vX6fDM2ZcwHFMYiSmMxhQmiymMiynMLqYweUxhUhtVmvSf0+TymcaR/jwupG6dFnL3C5uyb4ZV7O12VyHZDl97EkhPBukpID0VpGcG0tOB9NyB9MwxepIF6QniIQLxEIF4iASkJ4iHCMRDBOIhAvEQgXiIQTzEIB5iEA8xiIdYQHqCeIhBPMQgHmIQDzGIhwTEQwLiIQHxkIB4SASkJ4iHBMRDAuIhAfGQgHhIQTykIB5SEA8piIdUQHqCeEhBPKQgHlIID4VDNfi29af99j+K8PqlHHxZtfV6bC7dYfN1ej1/fAkr3gA=","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"70":{"source":"use std::runtime::is_unconstrained;\nuse std::hash::sha256_compression;\n\n/// Block size\nglobal BLOCK_SIZE: u32 = 64;\n\n/// First index in the block where the 8-byte message will be written.\nglobal MSG_LEN_PTR: u32 = 56;\n\n/// Size of message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n/// Size of unsigned 32 bit integer in bytes.\nglobal INT_SIZE: u32 = 4;\n\n/// Index of the integer in `INT_BLOCK` where the length is writen.\nglobal INT_SIZE_PTR: u32 = MSG_LEN_PTR / INT_SIZE;\n\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n/// Index of abyte in 64 byte block;\ntype BlockBytePtr = u32;\n\n/// Foreign function interface type\npub(crate) type IntBlock = [u32; INT_BLOCK_SIZE];\n\ntype MsgBlock = IntBlock;\n\ntype Hash = [u8; 32];\n\ntype State = [u32; 8];\n\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> Hash {\n    sha256_var(msg, N as u64)\n}\n\n/// SHA256 hash function\npub fn sha256_var<let N: u32>(msg: [u8; N], msg_len: u64) -> Hash {\n    let msg_len = msg_len as u32;\n\n    let num_blocks = N / BLOCK_SIZE;\n\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let mut state: State = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\n        0x5be0cd19,\n    ];\n\n    let mut msg_byte_ptr = 0;\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        if (msg_start < msg_len) & (msg_byte_ptr == BLOCK_SIZE) {\n            state = sha256_compression(msg_block, state);\n        }\n    }\n\n    let modulus = N % BLOCK_SIZE;\n\n    if modulus != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n\n    msg_byte_ptr += 1;\n\n    let last_block = msg_block;\n\n    if msg_byte_ptr > MSG_LEN_PTR {\n        state = sha256_compression(msg_block, state);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, msg_len) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, msg_len);\n    }\n\n    hash_final_block(msg_block, state)\n}\n\nunconstrained pub(crate) fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_start: u32,\n) -> (MsgBlock, BlockBytePtr) {\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let block_input = if msg_start + BLOCK_SIZE > msg_len {\n        if msg_len < msg_start {\n            0\n        } else {\n            msg_len - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    let mut int_input = block_input / INT_SIZE;\n\n    if block_input % INT_SIZE != 0 {\n        int_input += 1;\n    }\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n\n            msg_item = shl8(msg_item, 1) + msg_byte as u32;\n        }\n\n        msg_block[i] = msg_item;\n    }\n\n    (msg_block, block_input)\n}\n\npub(crate) fn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_block: MsgBlock,\n    msg_start: u32,\n) -> BlockBytePtr {\n    let mut msg_byte_ptr = 0;\n\n    let mut msg_end = msg_start + BLOCK_SIZE;\n\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    if msg_end % INT_SIZE != 0 {\n        msg_end += INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    let mut msg_item: u32 = 0;\n\n    let mut i: u32 = 0;\n\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            if (msg_start < msg_len) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n\n                i += 1;\n\n                msg_item = 0;\n            }\n        }\n\n        msg_item = shl8(msg_item, 1);\n\n        if k < msg_len & k < msg_end {\n            msg_item += msg[k] as u32;\n\n            msg_byte_ptr += 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\npub(crate) fn verify_msg_block_padding(msg_block: MsgBlock, msg_byte_ptr: BlockBytePtr) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\npub(crate) fn verify_msg_block_zeros(\n    msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    max_int_byte_ptr: u32,\n) {\n    let zero = msg_block[0] - msg_block[0];\n\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let zeros = INT_SIZE - modulus;\n\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n\n        int_byte_ptr += 1;\n    }\n\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\npub(crate) fn verify_msg_block_equals_last(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n) {\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let last_field = last_block[int_byte_ptr];\n\n        let mut msg_item: u32 = 0;\n\n        msg_byte_ptr -= modulus;\n\n        for i in 0..INT_SIZE {\n            msg_item = shl8(msg_item, 1);\n\n            if i < modulus {\n                msg_item += get_item_byte(last_field, msg_byte_ptr) as u32;\n\n                msg_byte_ptr += 1;\n            }\n        }\n\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\npub(crate) fn update_block_item<Env>(\n    mut msg_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    f: fn[Env](u32) -> u32,\n) -> MsgBlock {\n    let i = msg_byte_ptr / INT_SIZE;\n\n    msg_block[i] = f(msg_block[i]);\n\n    msg_block\n}\n\npub(crate) fn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BlockBytePtr, msg_byte: u8) -> u32 {\n    let zeros = (INT_SIZE - msg_byte_ptr % INT_SIZE) as u8;\n\n    let zeroed_item = shl8(shr8(msg_item, zeros), zeros);\n\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n\n    zeroed_item + new_item\n}\n\npub(crate) fn get_item_byte(mut msg_item: u32, msg_byte_ptr: BlockBytePtr) -> u8 {\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    msg_item = shr8(msg_item, shifts);\n\n    msg_item as u8\n}\n\npub(crate) fn byte_into_item(msg_byte: u8, msg_byte_ptr: BlockBytePtr) -> u32 {\n    let mut msg_item = msg_byte as u32;\n\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    shl8(msg_item, shifts)\n}\n\npub(crate) fn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = shl8(item, 1) + b1 as u32;\n    item = shl8(item, 1) + b2 as u32;\n    item = shl8(item, 1) + b3 as u32;\n\n    item\n}\n\npub(crate) fn shl8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\npub(crate) fn shr8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\nunconstrained pub(crate) fn attach_len_to_msg_block(\n    mut msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) -> MsgBlock {\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let i = msg_byte_ptr / INT_SIZE;\n\n        let zeros = (INT_SIZE - modulus) as u8;\n\n        msg_block[i] = shl8(shr8(msg_block[i], zeros), zeros);\n\n        msg_byte_ptr += zeros as u32;\n    }\n\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * msg_len;\n\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n\n    for i in 0..=1 {\n        let shift = i * 4;\n\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n\n    msg_block\n}\n\npub(crate) fn verify_msg_len(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    let mut reconstructed_len: u64 = 0;\n\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len *= TWO_POW_32;\n\n        reconstructed_len += msg_block[i] as u64;\n    }\n\n    let len = 8 * msg_len as u64;\n\n    assert_eq(reconstructed_len, len);\n}\n\npub(crate) fn hash_final_block(msg_block: MsgBlock, mut state: State) -> Hash {\n    let mut out_state: Hash = [0; 32];\n\n    state = sha256_compression(msg_block, state);\n\n    for j in 0..8 {\n        let state_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n\n        for k in 0..4 {\n            out_state[4 * j + k] = state_bytes[k];\n        }\n    }\n\n    out_state\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/sha256.nr"},"71":{"source":"use crate::sha256::{\n    attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n    set_item_byte_then_zeros, sha256_var, IntBlock, shl8, shr8,\n};\n\n#[test]\n#[export]\nfn test_keccak256_0() -> [u8; 32] {\n    sha256_var([], 0)\n}\n\n#[test]\nfn test_smoke() {\n    let input = [0xbd];\n\n    let result = [\n        0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05,\n        0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe,\n        0x73, 0x2b,\n    ];\n\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    let result = [\n        91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24,\n        65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_multiple_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n    ];\n    let result = [\n        116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60,\n        47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_under_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59,\n    ];\n    let result = [\n        143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165,\n        74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_not_block_multiple() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115,\n        97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n    ];\n    let result = [\n        112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55,\n        192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_with_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    let message_size = 297;\n    assert_eq(sha256_var(input, message_size), result);\n}\n\n#[test]\nfn msg_big_no_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn test_get_item_byte() {\n    let fld = make_item(10, 20, 30, 40);\n    assert_eq(fld, 0x0a141e28);\n    assert_eq(get_item_byte(fld, 0), 10);\n    assert_eq(get_item_byte(fld, 4), 10);\n    assert_eq(get_item_byte(fld, 6), 30);\n}\n\n#[test]\nfn test_byte_into_item() {\n    let fld = make_item(0, 20, 0, 0);\n    assert_eq(byte_into_item(20, 1), fld);\n    assert_eq(byte_into_item(20, 5), fld);\n}\n\n#[test]\nfn test_set_item_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 0, 0, 0);\n    assert_eq(shl8(shr8(fld0, 3), 3), fld1);\n    assert_eq(shl8(shr8(fld0, 4), 4), 0);\n    assert_eq(shl8(shr8(0, 4), 4), 0);\n}\n\n#[test]\nfn test_set_item_byte_then_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 50, 0, 0);\n    assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n}\n\n#[test]\nfn test_build_msg_block_start_0() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48,\n    ];\n    assert_eq(input.len(), 22);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n    assert_eq(msg_byte_ptr, input.len());\n    assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n    assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n    assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n    assert_eq(msg_block[6], 0);\n}\n\n#[test]\nfn test_build_msg_block_start_1() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    assert_eq(input.len(), 68);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n    assert_eq(msg_byte_ptr, 4);\n    assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n    assert_eq(msg_block[1], 0);\n}\n\n#[test]\nfn test_attach_len_to_msg_block() {\n    let input: IntBlock = [\n        2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n        1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n        1849316213, 1651139939,\n    ];\n    let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n    assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n    assert_eq(msg_block[1], 0);\n    assert_eq(msg_block[15], 3584);\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/tests.nr"}},"names":["test_keccak256_0"],"brillig_names":["attach_len_to_msg_block"]}