{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":15393917544943861500,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":511,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"7d3djt02Dgfwd5nrXEgkJZJ9lcWiSNu0GCBIiiZdYFHk3dfJ5uhMogMbA5ma/7FzUyStS/+kY9Lyl/TPw29vfvn7j58f3/3+/sPDT//65+Ht+19ff3x8/2752z+fXj388tfj27ePf/z89F8/pM//KIW+/A8f/nz97vPfP3x8/dfHh59KSa8e3rz7bfmT0hLg98e3bx5+0vzpVbdpzsm/bpsz8XXj9Onfr5b4HBxfguOX4fje4lNKXfwaHF+D41twfI+NX1Nw/Bwcn4Ljc3B8CY4fnL81OH9rcP7W4Pytwfmrwfmrwfmrwfmrwfmrwfmrwfmrw/nL0uJz8S6+Bse34PgeG99ScPwcHJ+C43NwfAmOX4LjB+evBeevBeevBeevB+evB+evB+evB+evB+evB+evB+evB+evB+evx+ZvTSk4fg6OT8HxOTi+BMcvwfFrcHwNjm/B8YPzNwfnbx7PX68tvmsXn4Ljc2x8GvZLbvGFahd/NH+J9PL7Eudvft9+Y650wSx/7BtbkTCKhDEkjANhOCFh8lyM0gWjSToMIWHmHsCarWG4+5lk7s+kxheMJeowhIRhJIwAYcrcY8ZUG8a7UVMhJAwjYQQJM3dw5e1NA3bOHaYiYRQJY0gYfzlMd3VQExJmbp1xaanttfuZqiBhChKmImEUCTM5ta1dqriX7zFKSJipB7Aw5a8bCzN3mOEDmLk0TOkuhYYfeW/EH37kvRU/B8en4PjDpVvbLTVS7g7m4Ue6W/E9Nv7wI1eydCmDZH1+DT+yJCst2a2mLn4Jjl+D42tw/OHhrtklvzh9exOs31hTu7+tOXeXSMPPH5+HycINU74/8jUlJExGwhAShpEwgoQpSJg6GZOvmLq+MXmVa+S0EZnbZakyU9dMPUcz7RzN9FM0M6eDNJPc1pqZz9FMOkcz+RzNlMM0U6/N9K6Z5RzNPMooaKOZhxkF1et50zc2Xp7+XRimlrs+OcyQacc+Ocz4ar8+oaMMxvbsk6OM3Pbsk6MM8/bsk6OMCffsE/nRJ12fHGW0+bw+qXTtk+5Cgw5zg65tvPSJbfQJte+1jZN93yd8nPPOM/qEK7c+Ue765Djnnf365Djnnf365Djnnf365Djnnf365JTnnY0+Oc79k/365Dj3T/brk+PcP3lOnxS59sn3L3SpHOf+yX59cs5x7HqfnHMcu94nRznvCF3IKmWjT9SpdaCLdn1ylPPOnn1ylPPOjn1SjnLe2bNPjnLeeV6f5LzWJ0c57+zZJ0e5f7Jnn8iPPun65Cj3T/bsk6PcP3lmn7SNvfuoR8s5x7HrfXLOcex6n5xzHFuv9cR464Jx9QZUPeegd8cOPOcIeccOPOdwescOPOfYe8cOlB8dONaB5xzV79iB57wE2LEDz3m98KwOXH1wUM95cbFjB/64EhnrQP1xJTLYgT+uRAY78DBXIrW0DrTufqMe5nphvZlyjmYeZuy93szJI2S6znLD3VvlqkgYQ8I4EMYSEiYjYQgJw0gYQcIUJAxSBTakCmxIFdiQKrAHVuAv8XNwfAqOz8HxJTj+aIHixNchYuk+8xyem3ErvgbHt+D4HhrfhmdQ3Iqfg+NTcHweju8tfv72EulLfAmOr8Hxh4//zG0O+ayli++x8YfnVduKn4PjU3B8Do4vwfFLcPwaHF+D4wfnbw7OXwrOXwrO3+EpYpjS5X7d8kfq4ktw/OH8Im4LDZBv3N6vyS/zY9Scu5PR8PwYu2IUCWNIGAfCDC9HuCsmI2EICcNIGJmJcWqzdjvV2mEKEqYiYRQJY3MxWhvGrMM4EEam1hnnttaJM3epLTwX015XcNZucCWChClImIqE0ckYvmK8wxgSxoEwZepIzyVf7qu7dPfVrWQkDCFhGAkjSJiChKlIGJ2MSQ3z7XJs/cbr05xasbuV+73Ka7pbeb5bOd2tnO9WLncrL8DytSmarU4+LabraVG23o1fnUjZquPKVz8NM013K893K6e7lfPdyuVu5eVu5cD1fEOuwPK1r7RM7W7lyOfQVbkhn0PX5ZPvS/t1rNi/DmEVCaNIGEPCOBDGExImI2EICcNIGJlbrq/Pv6S/5vWChKlIGEXCGA7G09yiV67jjULWYTISZm42Fc4NI9xh5h4zxdsD3JqkwzgQJickTEbCEBKGkTCChClImIqEmXvWrtxeSKviHcYmY9qrerXS+sZC5SJfnslfI1O9sXGRdIlchOTpxl+a6adoJqVzNDOfo5l0jmbyOZop52hmOUcz6zmaqedo5jlGQTz5hGLtFk217z9N9ckfFmlbpsq1m4fBJ39YtIFRJIwhYQKH8Z/jSwqOn4PjU3D84aEac5sOiL2rCeNfJEmyS3yRjdK6svEXTEHC1JmYnIpeXuZb/myp4ygWx7A4DsUZ/zJpX07G4hAWh7E4gsUpWBysqlywqnLBqsoFqypXrKpcsapyxarKFasqV6yqXLGqcp1clWtKjbPc2uk4isUxLI5DcTRhcTIWh7A4jMURLE7B4mBVZcWqyopVlRWrKtvsulPKlVN6zuTM0lobR63nKFbvzD6U/crR1N2zNofieMLiZCwOYXEYiyNYnPKCnNw9IvHZA4w2c/3CoY15HfZ8jO96lobaWRrq52hoTimdpqX5NC2l07SUT9NSOU1Ly2laOvl0quV6Ud+/zJVTzkiX0YuHwDwM5hEwj4Idz7PzS5/2zw2PY3kogXkymIfAPAzmETBPAfPUl/SU3qNgHgPzOJaHZ9dnu77GYd3txcWTwTwE5mEwj4B5CpingnkUazzPBuZxLI8kMA/Y9buAXb8L2PW7CJgH6jWKxVPBPGD1WcDqs4DV5wJWnwtYfS5g9Xnygkfa8K65H41NXvFoS6NQGoPSOJJm8nJDW5oMpSEoDUNpZK6Gn0zskHpNgdJUKI1CaSbXYm3TF6rfOIodSTN5qaAtTYbSEJSGoTQCpZlbiy03jVE/Sp+8RM6WRqE0BqWZW4stPdFop5m85MyWJkNpCErDUBqB0hQozeRaXNriAVb7kejkBYi2NAalcSTN5DWITJ5o+vdkJi9CtKUhKA1DaQRKU6A0FUozuRZbW+PGXHqNQWkcSJMnL420pZlci/WJpvQagtIwlEagNAVKU6E0CqWZfL/4ui6cp7q+8XK1czmpWermEVvoDkxvawxZ3tyY/PImoHGyrp2Tl9SKa+fqUr5LOxW3ncvB1tqZb/xEyFn05Ce6Rb+TLLpBn7ye0q70fL904HKU23qWlkXGyu7kpXLi2rlRdhk4i7Joa2c3ldVCB86ipz/RLfqdZNEtOt8vXe6XjlyO6nV09O1qz88vuww8lHpWOzfKriBnUbsrZPnGXSFBzqInP9Et+p1k0S16vV868pXdBh1oga1F40iakqA0GUpDUBqG0giUBmilw0UDtNThogFa63DRQNXiAlWLK1QtrlC1uELV4gpViyd/S1HaRa4X4V4zt96U60Cx1P6Se/K3FFsaR9JM/pZiS5OhNASlYSiNQGkKlKZCaaBqsULVYoWqxQZViw2qFhtULR7+XoCoLa5HnH1dI4kvgZc/9mO/4e8F9tUokmb4nfhnatpxI6lSr+GpGqqX+//CqX/xavi97301c3OKKTcN91cwXqE0CqUxKI0DaSglKE2G0hCUhqE0AqVBqsWUkGoxJaRaTAmpFlOCqsUZqhbnufUmtXc/JLn2GoHSFChNhdIolMagNI6koQSlyS+lySn3GoLSMJRGoDRza3Fu86BJFu80PDenlmc+TdOv3UCcoTQEpWEozdycWp4xXzW11xQoTYXSKJTGoDSOpJEEpZl8L729f7P8sa83MrfePLmXToNfapAoLn394wsqc8+AZGtPMKggPd2hIlCaAqWpUBqF0hiUxpE0NUFpMpRmtN5kKZcP1rPU/obG8OTlmzuo0TvQ6B1Y9A48eAfD76Nu7iBH72B0TJILXb6Wz+XbHfQbc6X2WlOlGxqG0giUpkBpKpRGoTQ2V9PuLXHtvyWl4bdGd9UMvzW6ryZDaeilNJpuaObmlOa2jJdyn1M+97hRu5w12RL1mgylISgNA2k4zT1urK2iwebeazKUhqA0DKWRqRpvM/2x9++FcypQmgqlUSiNvZym9hpH0uS59cbbNG7s/ezknBlKI1CaAqWpUJrJGW7tWtP7mZSZMpRm6lG88Q4r0/hR3AaXud4YXJJF78CDd8Apegc5egfDZdy8LQntuT+mh98/2dzB8FF0zUpK6cYOPHgH469apJzaDm6MHCSPt6Bcd6D9DiR6ByV6B8MPiVO9/gZ+4zfQ6B1Y9A48eAclRe8gR++AonfA0TuQ6B2U6B1EZ3KJzuQSncklOpNrdKLV6ESr0YlWoxOtTr2xszE1A1eD0jiSZu5LBBvTVvDcB+UbLxrx3Aflm5q5ObVxgT73QfmmxpE0cx+Ub2oylIagNAylEShNgdJUKA1ULTaoWmxQtdiharFD1WKHqsU+t96sf9TOXqE0CqUxKI0DaWTuS0ubmgylISgNv5TmxmQIkgRKU6A0FUoztxavT1shc1/M2ZgMQea+mLOpEShNgdLMzan1T+wlK5TGoDSOpKEEpclQGoLSTL6XvjptxXJz+6XupY9OWyHkuPT1aStkeHKiZ9JXp60QRnq6I4z0dEdYoTQGpXEkjSQoTYbSEJSGUTSflr/95/Vfj69/efvmw/L/fP6Pf7/79ePj+3df//rxv3/+/78sG/8P","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"70":{"source":"use std::runtime::is_unconstrained;\nuse std::hash::sha256_compression;\n\n/// Block size\nglobal BLOCK_SIZE: u32 = 64;\n\n/// First index in the block where the 8-byte message will be written.\nglobal MSG_LEN_PTR: u32 = 56;\n\n/// Size of message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n/// Size of unsigned 32 bit integer in bytes.\nglobal INT_SIZE: u32 = 4;\n\n/// Index of the integer in `INT_BLOCK` where the length is writen.\nglobal INT_SIZE_PTR: u32 = MSG_LEN_PTR / INT_SIZE;\n\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n/// Index of abyte in 64 byte block;\ntype BlockBytePtr = u32;\n\n/// Foreign function interface type\npub(crate) type IntBlock = [u32; INT_BLOCK_SIZE];\n\ntype MsgBlock = IntBlock;\n\ntype Hash = [u8; 32];\n\ntype State = [u32; 8];\n\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> Hash {\n    sha256_var(msg, N as u64)\n}\n\n/// SHA256 hash function\npub fn sha256_var<let N: u32>(msg: [u8; N], msg_len: u64) -> Hash {\n    let msg_len = msg_len as u32;\n\n    let num_blocks = N / BLOCK_SIZE;\n\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let mut state: State = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\n        0x5be0cd19,\n    ];\n\n    let mut msg_byte_ptr = 0;\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        if (msg_start < msg_len) & (msg_byte_ptr == BLOCK_SIZE) {\n            state = sha256_compression(msg_block, state);\n        }\n    }\n\n    let modulus = N % BLOCK_SIZE;\n\n    if modulus != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n\n    msg_byte_ptr += 1;\n\n    let last_block = msg_block;\n\n    if msg_byte_ptr > MSG_LEN_PTR {\n        state = sha256_compression(msg_block, state);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, msg_len) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, msg_len);\n    }\n\n    hash_final_block(msg_block, state)\n}\n\nunconstrained pub(crate) fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_start: u32,\n) -> (MsgBlock, BlockBytePtr) {\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let block_input = if msg_start + BLOCK_SIZE > msg_len {\n        if msg_len < msg_start {\n            0\n        } else {\n            msg_len - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    let mut int_input = block_input / INT_SIZE;\n\n    if block_input % INT_SIZE != 0 {\n        int_input += 1;\n    }\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n\n            msg_item = shl8(msg_item, 1) + msg_byte as u32;\n        }\n\n        msg_block[i] = msg_item;\n    }\n\n    (msg_block, block_input)\n}\n\npub(crate) fn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_block: MsgBlock,\n    msg_start: u32,\n) -> BlockBytePtr {\n    let mut msg_byte_ptr = 0;\n\n    let mut msg_end = msg_start + BLOCK_SIZE;\n\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    if msg_end % INT_SIZE != 0 {\n        msg_end += INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    let mut msg_item: u32 = 0;\n\n    let mut i: u32 = 0;\n\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            if (msg_start < msg_len) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n\n                i += 1;\n\n                msg_item = 0;\n            }\n        }\n\n        msg_item = shl8(msg_item, 1);\n\n        if k < msg_len & k < msg_end {\n            msg_item += msg[k] as u32;\n\n            msg_byte_ptr += 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\npub(crate) fn verify_msg_block_padding(msg_block: MsgBlock, msg_byte_ptr: BlockBytePtr) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\npub(crate) fn verify_msg_block_zeros(\n    msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    max_int_byte_ptr: u32,\n) {\n    let zero = msg_block[0] - msg_block[0];\n\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let zeros = INT_SIZE - modulus;\n\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n\n        int_byte_ptr += 1;\n    }\n\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\npub(crate) fn verify_msg_block_equals_last(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n) {\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let last_field = last_block[int_byte_ptr];\n\n        let mut msg_item: u32 = 0;\n\n        msg_byte_ptr -= modulus;\n\n        for i in 0..INT_SIZE {\n            msg_item = shl8(msg_item, 1);\n\n            if i < modulus {\n                msg_item += get_item_byte(last_field, msg_byte_ptr) as u32;\n\n                msg_byte_ptr += 1;\n            }\n        }\n\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\npub(crate) fn update_block_item<Env>(\n    mut msg_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    f: fn[Env](u32) -> u32,\n) -> MsgBlock {\n    let i = msg_byte_ptr / INT_SIZE;\n\n    msg_block[i] = f(msg_block[i]);\n\n    msg_block\n}\n\npub(crate) fn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BlockBytePtr, msg_byte: u8) -> u32 {\n    let zeros = (INT_SIZE - msg_byte_ptr % INT_SIZE) as u8;\n\n    let zeroed_item = shl8(shr8(msg_item, zeros), zeros);\n\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n\n    zeroed_item + new_item\n}\n\npub(crate) fn get_item_byte(mut msg_item: u32, msg_byte_ptr: BlockBytePtr) -> u8 {\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    msg_item = shr8(msg_item, shifts);\n\n    msg_item as u8\n}\n\npub(crate) fn byte_into_item(msg_byte: u8, msg_byte_ptr: BlockBytePtr) -> u32 {\n    let mut msg_item = msg_byte as u32;\n\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    shl8(msg_item, shifts)\n}\n\npub(crate) fn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = shl8(item, 1) + b1 as u32;\n    item = shl8(item, 1) + b2 as u32;\n    item = shl8(item, 1) + b3 as u32;\n\n    item\n}\n\npub(crate) fn shl8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\npub(crate) fn shr8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\nunconstrained pub(crate) fn attach_len_to_msg_block(\n    mut msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) -> MsgBlock {\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let i = msg_byte_ptr / INT_SIZE;\n\n        let zeros = (INT_SIZE - modulus) as u8;\n\n        msg_block[i] = shl8(shr8(msg_block[i], zeros), zeros);\n\n        msg_byte_ptr += zeros as u32;\n    }\n\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * msg_len;\n\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n\n    for i in 0..=1 {\n        let shift = i * 4;\n\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n\n    msg_block\n}\n\npub(crate) fn verify_msg_len(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    let mut reconstructed_len: u64 = 0;\n\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len *= TWO_POW_32;\n\n        reconstructed_len += msg_block[i] as u64;\n    }\n\n    let len = 8 * msg_len as u64;\n\n    assert_eq(reconstructed_len, len);\n}\n\npub(crate) fn hash_final_block(msg_block: MsgBlock, mut state: State) -> Hash {\n    let mut out_state: Hash = [0; 32];\n\n    state = sha256_compression(msg_block, state);\n\n    for j in 0..8 {\n        let state_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n\n        for k in 0..4 {\n            out_state[4 * j + k] = state_bytes[k];\n        }\n    }\n\n    out_state\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/sha256.nr"},"71":{"source":"use crate::sha256::{\n    attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n    set_item_byte_then_zeros, sha256_var, IntBlock, shl8, shr8,\n};\n\n#[test]\n#[export]\nfn test_sha256_0() -> [u8; 32] {\n    sha256_var([], 0)\n}\n\n#[test]\n#[export]\nfn test_sha256_1(input: [u8; 1], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_200(input: [u8; 200], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_511(input: [u8; 511], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_512(input: [u8; 512], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\nfn test_smoke() {\n    let input = [0xbd];\n\n    let result = [\n        0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05,\n        0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe,\n        0x73, 0x2b,\n    ];\n\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    let result = [\n        91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24,\n        65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_multiple_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n    ];\n    let result = [\n        116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60,\n        47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_under_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59,\n    ];\n    let result = [\n        143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165,\n        74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_not_block_multiple() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115,\n        97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n    ];\n    let result = [\n        112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55,\n        192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_with_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    let message_size = 297;\n    assert_eq(sha256_var(input, message_size), result);\n}\n\n#[test]\nfn msg_big_no_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn test_get_item_byte() {\n    let fld = make_item(10, 20, 30, 40);\n    assert_eq(fld, 0x0a141e28);\n    assert_eq(get_item_byte(fld, 0), 10);\n    assert_eq(get_item_byte(fld, 4), 10);\n    assert_eq(get_item_byte(fld, 6), 30);\n}\n\n#[test]\nfn test_byte_into_item() {\n    let fld = make_item(0, 20, 0, 0);\n    assert_eq(byte_into_item(20, 1), fld);\n    assert_eq(byte_into_item(20, 5), fld);\n}\n\n#[test]\nfn test_set_item_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 0, 0, 0);\n    assert_eq(shl8(shr8(fld0, 3), 3), fld1);\n    assert_eq(shl8(shr8(fld0, 4), 4), 0);\n    assert_eq(shl8(shr8(0, 4), 4), 0);\n}\n\n#[test]\nfn test_set_item_byte_then_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 50, 0, 0);\n    assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n}\n\n#[test]\nfn test_build_msg_block_start_0() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48,\n    ];\n    assert_eq(input.len(), 22);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n    assert_eq(msg_byte_ptr, input.len());\n    assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n    assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n    assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n    assert_eq(msg_block[6], 0);\n}\n\n#[test]\nfn test_build_msg_block_start_1() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    assert_eq(input.len(), 68);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n    assert_eq(msg_byte_ptr, 4);\n    assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n    assert_eq(msg_block[1], 0);\n}\n\n#[test]\nfn test_attach_len_to_msg_block() {\n    let input: IntBlock = [\n        2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n        1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n        1849316213, 1651139939,\n    ];\n    let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n    assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n    assert_eq(msg_block[1], 0);\n    assert_eq(msg_block[15], 3584);\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/tests.nr"}},"names":["test_sha256_511"],"brillig_names":["test_sha256_511"]}