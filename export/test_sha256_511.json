{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":6176409019736541695,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":511,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"71":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n","path":"/Users/joshuatrujillo/Documents/github/zk/noir/sha256/src/sha256.nr"},"72":{"source":"use crate::sha256::{\n    attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n    set_item_byte_then_zeros, sha256_var, sha256, set_item_zeros, INT_BLOCK,\n};\n\n#[export]\nfn test_sha256_0() -> [u8; 32] {\n    sha256_var([], 0)\n}\n\n#[export]\nfn test_sha256_1(input: [u8; 1], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[export]\nfn test_sha256_200(input: [u8; 200], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[export]\nfn test_sha256_511(input: [u8; 511], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[export]\nfn test_sha256_512(input: [u8; 512], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\nfn smoke_test() {\n    let input = [0xbd];\n    let result = [\n        0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05,\n        0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe,\n        0x73, 0x2b,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    let result = [\n        91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24,\n        65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_multiple_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n    ];\n    let result = [\n        116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60,\n        47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_under_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59,\n    ];\n    let result = [\n        143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165,\n        74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_not_block_multiple() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115,\n        97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n    ];\n    let result = [\n        112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55,\n        192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_with_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    let message_size = 297;\n    assert_eq(sha256_var(input, message_size), result);\n}\n\n#[test]\nfn msg_big_no_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn same_msg_len_variable_padding() {\n    let input = [\n        29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179,\n        218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53,\n        32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178,\n        186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113,\n        247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175,\n        120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44,\n        12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98,\n        90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146,\n        145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118,\n        4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246,\n        67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25,\n        48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213,\n        196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81,\n        125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113,\n        81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50,\n        50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130,\n        89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188,\n        50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29,\n        255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228,\n        175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n        101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157,\n        167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30,\n        63, 129, 143, 32, 96,\n    ];\n\n    // Prepare inputs of different lengths\n    let mut input_511 = [0; 511];\n    let mut input_512 = [0; 512]; // Next block\n    let mut input_575 = [0; 575];\n    let mut input_576 = [0; 576]; // Next block\n    for i in 0..input.len() {\n        input_511[i] = input[i];\n        input_512[i] = input[i];\n        input_575[i] = input[i];\n        input_576[i] = input[i];\n    }\n\n    // Compute hashes of all inputs (with same message length)\n    let fixed_length_hash = sha256(input);\n    let var_full_length_hash = sha256_var(input, input.len() as u64);\n    let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n    let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n    let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n    let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n    // All of the above should have produced the same hash\n    assert_eq(var_full_length_hash, fixed_length_hash);\n    assert_eq(var_length_hash_511, fixed_length_hash);\n    assert_eq(var_length_hash_512, fixed_length_hash);\n    assert_eq(var_length_hash_575, fixed_length_hash);\n    assert_eq(var_length_hash_576, fixed_length_hash);\n}\n\n#[test]\nfn test_get_item_byte() {\n    let fld = make_item(10, 20, 30, 40);\n    assert_eq(fld, 0x0a141e28);\n    assert_eq(get_item_byte(fld, 0), 10);\n    assert_eq(get_item_byte(fld, 4), 10);\n    assert_eq(get_item_byte(fld, 6), 30);\n}\n\n#[test]\nfn test_byte_into_item() {\n    let fld = make_item(0, 20, 0, 0);\n    assert_eq(byte_into_item(20, 1), fld);\n    assert_eq(byte_into_item(20, 5), fld);\n}\n\n#[test]\nfn test_set_item_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 0, 0, 0);\n    assert_eq(set_item_zeros(fld0, 3), fld1);\n    assert_eq(set_item_zeros(fld0, 4), 0);\n    assert_eq(set_item_zeros(0, 4), 0);\n}\n\n#[test]\nfn test_set_item_byte_then_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 50, 0, 0);\n    assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n}\n\n#[test]\nfn test_build_msg_block_start_0() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48,\n    ];\n    assert_eq(input.len(), 22);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n    assert_eq(msg_byte_ptr, input.len());\n    assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n    assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n    assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n    assert_eq(msg_block[6], 0);\n}\n\n#[test]\nfn test_build_msg_block_start_1() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    assert_eq(input.len(), 68);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n    assert_eq(msg_byte_ptr, 4);\n    assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n    assert_eq(msg_block[1], 0);\n}\n\n#[test]\nfn test_attach_len_to_msg_block() {\n    let input: INT_BLOCK = [\n        2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n        1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n        1849316213, 1651139939,\n    ];\n    let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n    assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n    assert_eq(msg_block[1], 0);\n    assert_eq(msg_block[15], 3584);\n}\n","path":"/Users/joshuatrujillo/Documents/github/zk/noir/sha256/src/tests.nr"}},"names":["test_sha256_511"],"brillig_names":["test_sha256_511"]}