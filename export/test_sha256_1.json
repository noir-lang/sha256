{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":12619611823689733013,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":1,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"70":{"source":"use std::runtime::is_unconstrained;\nuse std::hash::sha256_compression;\n\n/// Block size\nglobal BLOCK_SIZE: u32 = 64;\n\n/// First index in the block where the 8-byte message will be written.\nglobal MSG_LEN_PTR: u32 = 56;\n\n/// Size of message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n/// Size of unsigned 32 bit integer in bytes.\nglobal INT_SIZE: u32 = 4;\n\n/// Index of the integer in `INT_BLOCK` where the length is writen.\nglobal INT_SIZE_PTR: u32 = MSG_LEN_PTR / INT_SIZE;\n\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n/// Index of abyte in 64 byte block;\ntype BlockBytePtr = u32;\n\n/// Foreign function interface type\npub(crate) type IntBlock = [u32; INT_BLOCK_SIZE];\n\ntype MsgBlock = IntBlock;\n\ntype Hash = [u8; 32];\n\ntype State = [u32; 8];\n\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> Hash {\n    sha256_var(msg, N as u64)\n}\n\n/// SHA256 hash function\npub fn sha256_var<let N: u32>(msg: [u8; N], msg_len: u64) -> Hash {\n    let msg_len = msg_len as u32;\n\n    let num_blocks = N / BLOCK_SIZE;\n\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let mut state: State = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\n        0x5be0cd19,\n    ];\n\n    let mut msg_byte_ptr = 0;\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        if (msg_start < msg_len) & (msg_byte_ptr == BLOCK_SIZE) {\n            state = sha256_compression(msg_block, state);\n        }\n    }\n\n    let modulus = N % BLOCK_SIZE;\n\n    if modulus != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n\n    msg_byte_ptr += 1;\n\n    let last_block = msg_block;\n\n    if msg_byte_ptr > MSG_LEN_PTR {\n        state = sha256_compression(msg_block, state);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, msg_len) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, msg_len);\n    }\n\n    hash_final_block(msg_block, state)\n}\n\nunconstrained pub(crate) fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_start: u32,\n) -> (MsgBlock, BlockBytePtr) {\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let block_input = if msg_start + BLOCK_SIZE > msg_len {\n        if msg_len < msg_start {\n            0\n        } else {\n            msg_len - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    let mut int_input = block_input / INT_SIZE;\n\n    if block_input % INT_SIZE != 0 {\n        int_input += 1;\n    }\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n\n            msg_item = shl8(msg_item, 1) + msg_byte as u32;\n        }\n\n        msg_block[i] = msg_item;\n    }\n\n    (msg_block, block_input)\n}\n\npub(crate) fn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_block: MsgBlock,\n    msg_start: u32,\n) -> BlockBytePtr {\n    let mut msg_byte_ptr = 0;\n\n    let mut msg_end = msg_start + BLOCK_SIZE;\n\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    if msg_end % INT_SIZE != 0 {\n        msg_end += INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    let mut msg_item: u32 = 0;\n\n    let mut i: u32 = 0;\n\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            if (msg_start < msg_len) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n\n                i += 1;\n\n                msg_item = 0;\n            }\n        }\n\n        msg_item = shl8(msg_item, 1);\n\n        if k < msg_len & k < msg_end {\n            msg_item += msg[k] as u32;\n\n            msg_byte_ptr += 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\npub(crate) fn verify_msg_block_padding(msg_block: MsgBlock, msg_byte_ptr: BlockBytePtr) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\npub(crate) fn verify_msg_block_zeros(\n    msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    max_int_byte_ptr: u32,\n) {\n    let zero = msg_block[0] - msg_block[0];\n\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let zeros = INT_SIZE - modulus;\n\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n\n        int_byte_ptr += 1;\n    }\n\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\npub(crate) fn verify_msg_block_equals_last(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n) {\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let last_field = last_block[int_byte_ptr];\n\n        let mut msg_item: u32 = 0;\n\n        msg_byte_ptr -= modulus;\n\n        for i in 0..INT_SIZE {\n            msg_item = shl8(msg_item, 1);\n\n            if i < modulus {\n                msg_item += get_item_byte(last_field, msg_byte_ptr) as u32;\n\n                msg_byte_ptr += 1;\n            }\n        }\n\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\npub(crate) fn update_block_item<Env>(\n    mut msg_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    f: fn[Env](u32) -> u32,\n) -> MsgBlock {\n    let i = msg_byte_ptr / INT_SIZE;\n\n    msg_block[i] = f(msg_block[i]);\n\n    msg_block\n}\n\npub(crate) fn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BlockBytePtr, msg_byte: u8) -> u32 {\n    let zeros = (INT_SIZE - msg_byte_ptr % INT_SIZE) as u8;\n\n    let zeroed_item = shl8(shr8(msg_item, zeros), zeros);\n\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n\n    zeroed_item + new_item\n}\n\npub(crate) fn get_item_byte(mut msg_item: u32, msg_byte_ptr: BlockBytePtr) -> u8 {\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    msg_item = shr8(msg_item, shifts);\n\n    msg_item as u8\n}\n\npub(crate) fn byte_into_item(msg_byte: u8, msg_byte_ptr: BlockBytePtr) -> u32 {\n    let mut msg_item = msg_byte as u32;\n\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    shl8(msg_item, shifts)\n}\n\npub(crate) fn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = shl8(item, 1) + b1 as u32;\n    item = shl8(item, 1) + b2 as u32;\n    item = shl8(item, 1) + b3 as u32;\n\n    item\n}\n\npub(crate) fn shl8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\npub(crate) fn shr8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\nunconstrained pub(crate) fn attach_len_to_msg_block(\n    mut msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) -> MsgBlock {\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let i = msg_byte_ptr / INT_SIZE;\n\n        let zeros = (INT_SIZE - modulus) as u8;\n\n        msg_block[i] = shl8(shr8(msg_block[i], zeros), zeros);\n\n        msg_byte_ptr += zeros as u32;\n    }\n\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * msg_len;\n\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n\n    for i in 0..=1 {\n        let shift = i * 4;\n\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n\n    msg_block\n}\n\npub(crate) fn verify_msg_len(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    let mut reconstructed_len: u64 = 0;\n\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len *= TWO_POW_32;\n\n        reconstructed_len += msg_block[i] as u64;\n    }\n\n    let len = 8 * msg_len as u64;\n\n    assert_eq(reconstructed_len, len);\n}\n\npub(crate) fn hash_final_block(msg_block: MsgBlock, mut state: State) -> Hash {\n    let mut out_state: Hash = [0; 32];\n\n    state = sha256_compression(msg_block, state);\n\n    for j in 0..8 {\n        let state_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n\n        for k in 0..4 {\n            out_state[4 * j + k] = state_bytes[k];\n        }\n    }\n\n    out_state\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/sha256.nr"},"71":{"source":"use crate::sha256::{\n    attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n    set_item_byte_then_zeros, sha256_var, IntBlock, shl8, shr8,\n};\n\n#[test]\n#[export]\nfn test_sha256_0() -> [u8; 32] {\n    sha256_var([], 0)\n}\n\n#[test]\n#[export]\nfn test_sha256_1(input: [u8; 1], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_200(input: [u8; 200], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_511(input: [u8; 511], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_512(input: [u8; 512], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\nfn test_smoke() {\n    let input = [0xbd];\n\n    let result = [\n        0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05,\n        0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe,\n        0x73, 0x2b,\n    ];\n\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    let result = [\n        91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24,\n        65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_multiple_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n    ];\n    let result = [\n        116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60,\n        47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_under_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59,\n    ];\n    let result = [\n        143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165,\n        74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_not_block_multiple() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115,\n        97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n    ];\n    let result = [\n        112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55,\n        192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_with_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    let message_size = 297;\n    assert_eq(sha256_var(input, message_size), result);\n}\n\n#[test]\nfn msg_big_no_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn test_get_item_byte() {\n    let fld = make_item(10, 20, 30, 40);\n    assert_eq(fld, 0x0a141e28);\n    assert_eq(get_item_byte(fld, 0), 10);\n    assert_eq(get_item_byte(fld, 4), 10);\n    assert_eq(get_item_byte(fld, 6), 30);\n}\n\n#[test]\nfn test_byte_into_item() {\n    let fld = make_item(0, 20, 0, 0);\n    assert_eq(byte_into_item(20, 1), fld);\n    assert_eq(byte_into_item(20, 5), fld);\n}\n\n#[test]\nfn test_set_item_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 0, 0, 0);\n    assert_eq(shl8(shr8(fld0, 3), 3), fld1);\n    assert_eq(shl8(shr8(fld0, 4), 4), 0);\n    assert_eq(shl8(shr8(0, 4), 4), 0);\n}\n\n#[test]\nfn test_set_item_byte_then_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 50, 0, 0);\n    assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n}\n\n#[test]\nfn test_build_msg_block_start_0() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48,\n    ];\n    assert_eq(input.len(), 22);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n    assert_eq(msg_byte_ptr, input.len());\n    assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n    assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n    assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n    assert_eq(msg_block[6], 0);\n}\n\n#[test]\nfn test_build_msg_block_start_1() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    assert_eq(input.len(), 68);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n    assert_eq(msg_byte_ptr, 4);\n    assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n    assert_eq(msg_block[1], 0);\n}\n\n#[test]\nfn test_attach_len_to_msg_block() {\n    let input: IntBlock = [\n        2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n        1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n        1849316213, 1651139939,\n    ];\n    let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n    assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n    assert_eq(msg_block[1], 0);\n    assert_eq(msg_block[15], 3584);\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/tests.nr"}},"names":["test_sha256_1"],"brillig_names":["test_sha256_1"]}