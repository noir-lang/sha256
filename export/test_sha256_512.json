{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":17241472764505527140,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":512,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9WdB3gURR/G75JLQhJCQiAJ3YBSRIFLSCAUJRR7F3sPEASlCaHZiL13wa7YsGDvXURBUFHsXbAXULCL9fsP3pCXybx3Zy6n3/+e531S7rczv53tu7O7wcDfn+KUQCAY+T0t8jMl8jOIf+D/5FMZ+RlO7FPSiGWFk+UYVOCYosAxVYFjSIFjmgLHdAWOGQocmyhwzFTgmKXAMVuBY1MFjjkKHJspcMxV4JinwLG5Asd8BY4tFDi2VOBYoMCxUIFjkQLHVgocWytwbKPAsa0Cx3YKHNsrcOygwHETBY7FChw7KnDspMBxUwWOmylw7KzAsYsCx64KHLspcNxcgWN3BY5bKHDcUoFjDwWOPRU49lLgGFbgWKLAsVSBY28FjmUKHMsVOPZR4NhXgWOFAsd+Chz7K3AcoMBxoALHrRQ4bq3AcZACx0oFjoMVOA5R4DhUgeMwBY7bKHDcVoHjdgoct1fguIMCxx0VOO6kwHFnBY67KHDcVYHjbgocd1fguIcCxz0VOA5X4LiXAse9FTjuo8BxXwWO+ylw3F+B4wEKHA9U4HiQAseDFTgeosDxUAWOhylwrFLgOEKB40gFjqMUOFYrcBytwPFwBY5jFDiOVeB4hALHIxU4jlPgOF6B4wQFjhMVOE5S4HiUAsfJChynKHCsUeA4VYHjNAWO0xU4zlDgOFOB49EKHI9R4HisAsfjFDger8BxlgLHWgWOJyhwPFGB40kKHE9W4HiKAsdTFTiepsDxdAWOZyhwPFOB41kKHM9W4HiOAsdzFTiep8DxfAWOFyhwvFCB40UKHC9W4DhbgeMcBY6XKHC8VIHjZQocL1fgeIUCxysVOF6lwPFqBY7XKHCcq8DxWgWO1ylwvF6B4w0KHG9U4DhPgeNNChxvVuB4iwLHWxU4zlfgeJsCx9sVON6hwPFOBY53KXC8W4HjPQoc71XgeJ8Cx/sVOD6gwPFBBY4PKXB8WIHjIwocH1Xg+JgCx8cVOD6hwPFJBY4LFDg+pcBxoQLHpxU4PqPAcZECx8UKHJ9V4LhEgeNSBY7PKXB8XoHjCwoclylwfFGB40sKHJcrcHxZgeMrChxfVeD4mgLH1xU4vqHA8U0Fjm8pcHxbgeM7ChzfVeD4ngLH9xU4fqDAcYUCx5UKHD9U4PiRAsePFTh+osDxUwWOnylw/FyB4xcKHL9U4PiVAsdVChxXK3D8WoHjNwoc1yhwXKvA8VsFjt8pcPxegeMPChx/VOD4kwLHnxU4/qLAcZ0Cx18VOP6mwPF3BY5/KHD8U4HjXwocTYH/745BBY4pChxTFTiGFDimKXBMV+CYocCxiQLHTAWOWQocsxU4NlXgmKPAsZkCx1wFjnkKHJsrcMxX4NhCgWNLBY4FChwLFTgWKXBspcCxtQLHNgoc2ypwbKfAsb0Cxw4KHDdR4FiswLGjAsdOChw3VeC4mQLHzgocuyhw7KrAsZsCx80VOHZX4LiFAsctFTj2UODYU4FjLwWOYQWOJQocSxU49lbgWKbAsVyBYx8Fjn0VOFYocOynwLG/AscBChwHKnDcSoHj1gocBylwrFTgOFiB4xAFjkMVOA5T4LiNAsdtFThup8BxewWOOyhw3FGB404KHHdW4LiLAsddFTjupsBxdwWOeyhw3FOB43AFjnspcNxbgeM+Chz3VeC4nwLH/RU4HqDA8UAFjgcpcDxYgeMhChwPVeB4mALHKgWOIxQ4jlTgOEqBY7UCx9EKHA9X4DhGgeNYBY5HKHA8UoHjOAWO4xU4TlDgOFGB4yQFjkcpcJyswHGKAscaBY5TFThOU+A4XYHjDAWOMxU4Hq3A8RgFjscqcDxOgePxChxnKXCsVeB4ggLHExU4nqTA8WQFjqcocDxVgeNpChxPV+B4hgLHMxU4nqXA8WwFjucocDxXgeN5ChzPV+B4gQLHCxU4XqTA8WIFjrMVOM5R4HiJAsdLFThepsDxcgWOVyhwvFKB41UKHK9W4HiNAse5ChyvVeB4nQLH6xU43qDA8UYFjvMUON6kwPFmBY63KHC8VYHjfAWOtylwvF2B4x0KHO9U4HiXAse7FTjeo8DxXgWO9ylwvF+B4wMKHB9U4PiQAseHFTg+osDxUQWOjylwfFyB4xMKHJ9U4LhAgeNTChwXKnB8WoHjMwocFylwXKzA8VkFjksUOC5V4PicAsfnFTi+oMBxmQLHFxU4vqTAcbkCx5cVOL6iwPFVBY6vKXB8XYHjGwoc31Tg+JYCx7cVOL6jwPFdBY7vKXB8X4HjBwocVyhwXKnA8UMFjh8pcPxYgeMnChw/VeD4mQLHzxU4fqHA8UsFjl8pcFylwHG1AsevFTh+o8BxjQLHtQocv1Xg+J0Cx+8VOP6gwPFHBY4/KXD8WYHjLwoc1ylw/FWB428KHH9X4PiHAsc/FTj+lQTHZHgGUhrPMwiOxfZ3KT9FkioJSdIk6ZIMSRNJpiRLki1pKsmRNJPkSvIkzSX5khaSlpICSaGkSNJK0lrSRtJW0k7SXtJBsomkOAUksAHNn6mSkCRNki7JkDSRZEqyJNmSppIcSTNJriRP0lySL2khaSkpkBRKiiStJK0lbSRtJe0k7SUdJJtEGqWjpJNkU8lmks6SLpKukm6SzSXdJVtItpT0kPSU9DITSFIiKZX0lpRJyiV9JH0lFZJ+kv6SAZKBkq0kW0sGRWaawZIhkqGSYZJtJNtKtpNsL9lBsqNkJ8nOkl0ku0p2k+wu2UOyp2S4ZC/J3pJ9JPtK9pPsLzlAcqDkIMnBkkMkh0oOk1RJRkhGSkZJqiWjJYdLxkjGSo6QHCkZJxkvmSCZKJkkOUoyWTJFUiOZKpkmmS6ZIZkpOVpyjORYyXGS4yWzJLWSEyQnSk6SnCw5RXKq5DTJ6ZIzJGdKzpKcLTlHcq7kPMn5kgskF0ouklwsmS2ZI7lEcqnkMsnlkiskV0quklwtuUYyV3Kt5DrJ9ZIbJDdK5kluktwsuUVyq2S+5DbJ7ZI7JHdK7pLcLblHcq/kPsn9kgckD0oekjwseUTyqOQxyeOSJyRPShZInpIslDwteUaySLJY8qxkiWSp5DnJ85IXJMskL0pekiyXvCx5RfKq5DXJ65I3JG9K3pK8LXlH8q7kPcn7kg8kKyQrJR9KPpJ8LPlE8qnkM8nnki8kX0q+kqySrJZ8LflGskayVvKt5DvJ95IfJD9KfpL8LPlFsk7yq+Q3ye+SPyR/Sv6SmIU/KEmRpEpCkjRJuiRD0kSSKcmSZEuaSnIkzSS5kjxJc0m+pIWkpaRAUigpkrSStJa0kbSVtJO0l3SQbCIplnSUdJJsKtlM0lnSRdJV0k2yuaS7ZAvJlpIekp6SXhKzhi2RlEp6S8ok5ZI+kr6SCkk/SX/JAMlAyVaSrSWDzAZJMlgyRDJUYl44b17obl6Ybl5Ibl74bV6obV5YbV4IbV64bF5obF4YbF7Ia154a14oa17Yal6Ial44al7oaV6YaV5IaV74aF6oaF5YaF4IaF64Z15oZ14YZ17IdpjEvFDMvLDLvBDLvHDKvNDJvDDJvJDIvPDHvFDHvLDGvBDGvHDFvNDEvDDEvJDDvPDCvFDCvLDBvBDBvHDAPNDfPDDfPJDePPDdPFDdPLDcPBDcPHDbPNDaPDDaPJC5VmIeKGwe2GseiGseOGse6GoemGoeSGoe+GkeqGkeWGkeCGkeuGgeaGgeGGgeyGceeGceKGce2GYeiGYeOGYe6GUemGUeSGUe+GQeqGQeWGQeCGQeuGMeaGMeGGMeyDJXYh4oYh7YYR6IYR44YR7oYB6YYB5IYG74NzfUmxvWzQ3h5oZrc0OzuWHY3JBrbng1N5SaGzbNDZHmhkNzQ5+5Yc7ckGZu+DI3VJkblswNQeaGG3NDi7lhxNyQsUBibigwHfZNh3jT4dx06DYdpk2HZNPh13SoNR1WTYdQ0+HSdGg0HQZNhzzT4c10KDMdtkyHKNPhyHToMR1mTIcU0+HDdKgwHRZMhwBzwd1c0DYXjM0FWXPB01xQNBfszAUxc8HJXNAxF0zMBQlzwt+cUDcnrM0JYXPC1ZzQNCcMzQk5c8LLnFAyJ2zMCRFzwsEc0JsDZnNAag74zAGVOWAxBwRmh9vs0JodRrNDFoD9gOLIz/96B6XCetSpBWaBZ+vIz8GTJ1fNLB47YVT1jOKJU2uKJ44uHjFx6oRRU3DAM2HAjpGfVTU11eMn1RTXTCyeMnVEzeSqkTXF08fWjCmeOK168uhxE6djAbOjFzB+6riasZPGzeQFXJ9oATdBAZ3qFzBibE2PKWPGjo4yDvcl2ghPJjoOzyQ8DkughHb1S6gaNYoP+0JD554VCVSamxq1zWI3emFqA607Rq859tTqkWgBJVBAwyZ3v4aO/BAY8J9Osr0SHe9rGmr9QALWTyVqvSiBypc2dIyXN3TA9xKw/SzRplqVQOVrGjrGPyVQ6a8NrTQYanilaaEGVto0gUrzGlppxwQq7ZnAsAMSGHZQQ0d2pwQq3bOhlR6cQKVjYNgGLbKTE6j8+OiVx96GX5xA5YsSGPb1hk6qlQlUuirRSbUmgcp/SWDY3xvaWrlpDa+0ZQLDtoFhm0V+Dq+pGnmkDDmxeFR19aQNR0/DImhm5O8NZ4ADf5/xrYz8HU7sU5IJ5TZ2+RWlfcoyAxt/Gtm/dyaU2ejll/7dPqbMUHL8wxmRcobWblx+wKk31eHcYXC4YcAMI8w2wGxDmG2B2ZYw2wGzHWG2B2Z7wuwAzA6E2RGYHQmzEzA7EWZnYHYmzC7A7EKYXYHZlTC7AbMbYXYHZnfC7AHMHoTZE5g9CTMcmOGE2QuYvQizNzB7E2YfYPYhzL7A7EuY/YDZjzD7A7M/YQ4A5gDCHAjMgYQ5CJiDCHMwMAcT5hBgDiHMocAcSpjDgDmMMFXAVBFmBDAjCDMSmJGEGQXMKMJUA1NNmNHAjCbM4cAcTpgxwIwhzFhgxhLmCGCOIMyRwBxJmHHAjCPMeGDGE2YCMBMIMxGYiYSZBMwkwhwFzFGEmQzMZMJMAWYKYWqAqSHMVGCmEmYaMNMIMx2Y6YSZAcwMwswEZiZhjgbmaMIcA8wxhDkWmGMJcxwwxxHmeGCOJ8wsYGYRphaYWsKcAMwJhDkRmBMJcxIwJxHmZGBOJswpwJxCmFOBOZUwpwFzGmFOB+Z0wpwBzBmEOROYMwlzFjBnEeZsYM4mzDnAnEOYc4E5lzDnAXMeYc4H5nzCXADMBYS5EJgLCXMRMBcR5mJgLibMbGBmE2YOMHMIcwkwlxDmUmAuJcxlwFxGmMuBuZwwVwBzBWGuBOZKwlwFzFWEuRqYqwlzDTDXEGYuMHMJcy0w1xLmOmCuI8z1wFxPmBuAuYEwNwJzI2HmATOPMDcBcxNhbgbmZsLcAswthLkVmFsJMx+Y+YS5DZjbCHM7MLcT5g5g7iDMncDcSZi7gLmLMHcDczdh7gHmHsLcC8y9hLkPmPsIcz8w9xPmAWAeIMyDwDxImIeAeYgwDwPzMGEeAeYRwjwKzKOEeQyYxwjzODCPE+YJYJ4gzJPAPEmYBcAsIMxTwDxFmIXALCTM08A8TZhngHmGMIuAWUSYxcAsJsyzwDxLmCXALCHMUmCWEuY5YJ4jzPPAPE+YF4B5gTDLgFlGmBeBeZEwLwHzEmGWA7OcMC8D8zJhXgHmFcK8CsyrhHkNmNcI8zowrxPmDWDeIMybwLxJmLeAeYswbwPzNmHeAeYdwrwLzLuEeQ+Y9wjzPjDvE+YDYD4gzApgVhBmJTArCfMhMB8S5iNgPiLMx8B8TJhPgPmEMJ8C8ylhPgPmM8J8DsznhPkCmC8I8yUwXxLmK2C+IswqYFYRZjUwqwnzNTBfE+YbYL4hzBpg1hBmLTBrCfMtMN8S5jtgviPM98B8T5gfgPmBMD8C8yNhfgLmJ8L8DMzPhPkFmF8Isw6YdYT5FZhfCfMbML8R5ndgfifMH8D8QZg/gfmTMH8B8xdh1t+K4PzuMkFggoRJASaFMKnApBImBEyIMGnApBEmHZh0wmQAk0GYJsA0IUwmMJmEyQImizDZwGQTpikwTQmTA0wOYZoB04wwucDkEiYPmDzCNAemOWHygcknTAtgWhCmJTAtCVMATAFhCoEpJEwRMEWEaQVMK8K0BqY1YdoA04YwbYFpS5h2wLQjTHtg2hOmAzAdCLMJMJsQphiYYsJ0BKYjYToB04kwmwKzKWE2A2YzwnQGpjNhugDThTBdgelKmG7AdCPM5sBsTpjuwHQnzBbAbEGYLYHZkjA9gOlBmJ7A9CRML2B6ESYMTJgwJcCUEKYUmFLC9AamN2HKgCkjTDkw5YTpA0wfwvQFpi9hKoCpIEw/YPoRpj8w/QkzAJgBhBkIzEDCbAXMVoTZGpitCTMImEGEqQSmkjCDgRlMmCHADCHMUGCGEmYYMMMIsw0w2xBmW2C2Jcx2wGxHmO2B2Z4wOwCzA2F2BGZHwuwEzE6E2RmYnQmzCzC7EGZXYHYlzG7A7EaY3YHZnTB7ALMHYfYEZk/CDAdmOGH2AmYvwuwNzN6E2QeYfQizLzD7EmY/YPYjzP7A7E+YA4A5gDAHAnMgYQ4C5iDCHAzMwYQ5BJhDCHMoMIcS5jBgDiNMFTBVhBkBzAjCjARmJGFGATOKMNXAVBNmNDCjCXM4MIcTZgwwYwgzFpixhDkCmCMIcyQwRxJmHDDjCDMemPGEmQDMBMJMBGYiYSYBM4kwRwFzFGEmAzOZMFOAmUKYGmBqCDMVmKmEmQbMNMJMB2Y6YWYAM4MwM4GZSZijgTmaMMcAcwxhjgXmWMIcB8xxhDkemOMJMwuYWYSpBaaWMCcAcwJhTgTmRMKcBMxJhDkZmJMJcwowpxDmVGBOJcxpwJxGmNOBOZ0wZwBzBmHOBOZMwpwFzFmEORuYswlzDjDnEOZcYM4lzHnAnEeY84E5nzAXAHMBYS4E5kLCXATMRYS5GJiLCTMbmNmEmQPMHMJcAswlhLkUmEsJcxkwlxHmcmAuJ8wVwFxBmCuBuZIwVwFzFWGuBuZqwlwDzDWEmQvMXMJcC8y1hLkOmOsIcz0w1xPmBmBuIMyNwNxImHnAzCPMTcDcRJibgbmZMLcAcwthbgXmVsLMB2Y+YW4D5jbC3A7M7YS5A5g7CHMnMHcS5i5g7iLM3cDcTZh7gLmHMPcCcy9h7gPmPsLcD8z9hHkAmAcI8yAwDxLmIWAeIszDwDxMmEeAeYQwjwLzKGEeA+YxwjwOzOOEeQKYJwjzJDBPEmYBMAsI8xQwTxFmITALCfM0ME8T5hlgniHMImAWEWYxMIsJ8ywwzxJmCTBLCLMUmKWEeQ6Y5wjzPDDPE+YFYF4gzDJglhHmRWBeJMxLwLxEmOXALCfMy8C8TJhXgHmFMK8C8yphXgPmNcK8DszrhHkDmDcI8yYwbxLmLWDeIszbwLxNmHeAeYcw7wLzLmHeA+Y9wrwPzPuE+QCYDwizApgVhFkJzErCfAjMh4T5CJiPCPMxMB8T5hNgPiHMp8B8SpjPgPmMMJ8D8zlhvgDmC8J8CcyXhPkKmK8IswqYVYRZDcxqwnwNzNeE+QaYbwizBpg1hFkLzFrCfAvMt4T5DpjvCPM9MN8T5gdgfiDMj8D8SJifgPmJMD8D8zNhfgHmF8KsA2YdYX4F5lfC/AbMb4T5HZjfCfMHMH8Q5k9g/iTMX8D8RZj1jyF1fneZIDBBwqQAk0KYVGBSCRMCJkSYNGDSCJMOTDphMoDJIEwTYJoQJhOYTMJkAZNFmGxgsgnTFJimhMkBJocwzYBpRphcYHIJkwdMHmGaA9OcMPnA5BOmBTAtCNMSmJaEKQCmgDCFwBQSpgiYIsK0AqYVYVoD05owbYBpQ5i2wLQlTDtg2hGmPTDtCdMBmA6E2QSYTQhTDEwxYToC05EwnYDpRJhNgdmUMJsBsxlhOgPTmTBdgOlCmK7AdCVMN2C6EWZzYDYnTHdguhNmC2C2IMyWwGxJmB7A9CBMT2B6EqYXML0IEwYmTJgSYEoIUwpMKWF6A9ObMGXAlBGmHJhywvQBpg9h+gLTlzAVwFQQph8w/QjTH5j+hBkAzADCDARmIGG2AmYrwmwNzNaEGQTMIMJUAlNJmMHADCbMEGCGEGYoMEOBMc8JygQ+AMNVRv4OJ/CpCJf1TuqzkErD4RxnXAMwLrbutOTUXRJ06guAB35n689yXBvVJ/y3D9Znfdz2SYn8zLFMbZ1P0PkuVFt/POx3afCdnb7mLRLtU+o437yF31kX87HzpimjW8rGTimecQp6ximZz/aqKC0rS+6zvUrDvmniTq9Q7cZ143expol5c8ewSDsXQ5uZT0ZtMsap7tUoTSLlp4G3rRPdUxze/T3N+V9XmFfWjw+wG44B4X+2ztzI3+nwXWZt7LJCnrLyPHy6U1aGpyz8nx1v80aWDpE/zJtYzPQrSqsbzl2npcDvqcDgPIp8CJgU5/9YTo7zf/vd+vEMJHHdGi5p8Lo1Sc/ci7puxfZx10PpyfEJ2/IzktP+4aBTPo5vhqf97bzSxPOdLcuuZ9KgLOQzoA2Rx9/t8Pi/AZFGz/OUme44NPGMD/4Pl8HyyB+5Af8yhOX65os0T7l5Ab5s5niGC5Kfth73f249PudkzTvlI6rDI0eV9LPlN2ns8kvC1eWlfUfb8jMbufwRI/r0raquKLflZzVy+SWjK3qP6lc1wpaf3cjlV5WXjR5d3rvKlt+0kcvvUxXuV92nT187n9p9DlsHzlvNGrnuyKdfvNsFW3+W45qs7UIzx8dtH9yHM9/lelzzPN/hNMTvsJ5cTz2+sjIbWJadpnkwfGO0Ye+RfapH9+5b6nPNa8Txzm7Espo0sCzbhs1h+MZow34jwuV9KipG+lybN+J4ZzViWXa7Y7eruK7IcerxLVfNotSDw1suxzNcottVn3OOM36NUQ9uo+2+TLK2r5FPWbK2r5FPSbK2r5FPhW/7Ggw0/r53Y29f//6UbSg/Jzn+Fe45M5y3zM+JzrkXu+zifjsOmwXfI18VqitzsrMvjctDhjOeG46zA/XP9WC7pzn8tJS6+mY4xwQZZFxnOF44Xnbf2X4X8jjnBurPC+742PZgx+Z2OU7WdvbvT90xXXNoP3fdjfWnOXxtpK3yA/5P0Bk+EIh+/tH1QR7bwLr5poMdNlnb18inzLrmg6d1berxsXwLGOdUpwwf7057t/wWpO2Qx+2Cux9l604P+NvaDpvm8GfFmPbxjJuvvnzHP9UzrDsOblulwP9yPPXbecNtu8rI3+EEP27bhgL1p7+73CE/x1nfFgQ2blO3Ddx2bemptwCYHKfelk69sZZn+312wL/+cqdPCHx884W7H4PDm09l5Gc4sU9Jcqd7aTjNGd9bYftzZYq/TeKdVwuS4lw3r8aaZ9x51fI3OONVFPl/qmdcffNqoafeImDcebXQqTfWvGrrywr45z33vF2+U5/LtHC+t/zNMXx8176sm5k/botyjSzdw/2/bt/sfBHv9s09P++Wb8tL7j52uHeQtKdbJ5tfcPuJjLtvavn7G3H7ifXFs/10x6Gh66SWTjmVkb/DCX7ctsV1Q0uPj9u2C5x1UqHTprHWSQWeeguBcddJBU69bJomd5mtqNduuM6LNv3ddoy1zrP8ojjXwXg9zHf8lk980gkfIj5L/9P2Lwn7tiG+4yk23y6LYxtiPtgXIBXGzXxCtUkZtxJzHNAurc4Dp8n6cYF6cRwDgfrT0HzcY758D4/TybZfXoBvw33Hg6lOPb7tje96bZ5neLcet2z8PdUzPqlR6gl6nH3X7IJRHDLIuPoczO/s/H864d3lzvIrY8y3vnMu/3ZbJvUdf+HeFW4bsnNjrA2/gGOFdVHOQbnnsKP1xchNyrjGf83N1v9v9cXwXYPwrXP+7e0A+qRG8WmZFJ9whbtfgz6+dZ9pl1jXj3D9i962DnveyDcPu/sf/3T59q3ffddhQs537JxvtOXNDhNteYtneYg1HkGnnmRdM7K8Hddcj0O05SnaNT3fsv9fHqdi2yR6nOquS93y3WMhO3wo4N8HTIf6Wd3m4+4jZkcqNcNvk7pxnbHaoAlpAxwnZNx5wy7b6WSc3HPFls+LSMQ61sXzTW57+uorcPxTPcO642Dnx0Jn2MrI3+GEPnXr/iJoC9/8Vei0leWLYrRV0Bke28+3DnB9kMc2sPXZ9QK2bRGpm50ncM/ZtHKGr4z8HU7w444bHq+38vi4bd3JWX7aOO3jtpE7T7b21NsGGPc8QWun3ljT2HrieXacLoUOj+ctUgP1p12642P5MlindEn1l/n/Mq1954ujTWvL94xjWkdb/zR0WveMc1rb+vCcDU479/y/u/5wmRakHUpj+Nj9D9z+WTczf/RJ5Vy6h/Ndc0nG+hanu29967aH5fvHOX1awP/iWd+29PDYBra+vED9+c22qW1j93oaDhftulu06+6+baPvvFuqp3z3vNvQGG3o2w/Ng7rsfoxvn9Q9p5EB4xNtHyTJx8DVvj4zGTBOO6b6vdl5ATxvgPyu0GdmF1Im7sNiH6p/53i3bt1spyluf5p7fNIcfm9nvOxygtM4w1OO5fM99eKy5vZHynfqjbVfivXhcVlS77koqbuXEZfjoFN3kqZp3Od48Pqquw5KxjmeaH2DAoGNz2E0D/Dph2VtuN/DNmp+ckaiwncCH1f25hOC7/JBsCRtY8eU5DiWxuoMOMpZWH2dx3BYd6G3/ArY6Tzc2QBEO+nuO2kS9HwX7QSX74SFW0/QKQvrcRcKtjOQR4bH79I89fgc4jnxG89Ci37RbjBK7gX30rhv6LP1ZwX87VXZKD51K5imjo/bPu5GNTk3kpRu2KjmeHxyPO3jdmp3p527k5Hq4XNgHJHH3+3w+L/ayITznYR1O13H24HfrBeOdtYLOD7uRTHfdGvqKde33LltiMM1dNnKi+Icz3LX2DeDRT5xb9ht/f/Wcpft+AQD0S+WJGe5qzug9M2nwSg+STrQ2HDxxncw51sv4cUbnId8N8K43rYO9+INzhfuchcMxNdO0S5mx3MTLO7v4P7InFS/D67jcFj3YMDyV8D+yGXOese3PcoORN9fSfJyXOFuH9j4Zjvja/m5cZ74iHe5jLa9wjawvO8m6hxSjzuv/4frz3JN60+2fmgeqN++GR73DfuYyV3phst8B0ZWwndgZP+HB0axes7e5awo7MjjgoPDulezLP8wrCjuJSufQMC/MLo9blLBz8cHicODcZ7F9ZWFK03fCszdabTTAc8y4VVCd0OYpDu96+0Q49meZh4fd4W30JlWdmOHZ5l8KyrL53rqjXanTK5Tb6wVbawVZ9D53Y5zOuHdKxKWXxzDJ8nTscxtT7b8NXP8Lf9cnO3p24HzrRBdH+SbOUwgULfMYFu7vR2SszNYWu9MK7ZdjsfHPdP6chzrjfXjX7uxvx038wnVJmXcvD1McRqmQb2xppf5uNPXtwON08mOe16g/rKd7XyH60h3Hkn11IPztbsNsGWz3s64nUL+/Ti3Ab6yfNtDWw6u53G74F5ZSVJvtQ3zuD2Dj+vblh6fNIf/3Bkv7P2f6owrlmN531V0t7cI1lvg1MumR67jGQzUP5npu2rorkt8rqxHTkviujrObUByesnUHbw0tJfM2ji3Ab5eMr6rBa4P8on2kgmQccskdacH/llb/BzntMReEsmYlq3Bz9d2rRx/y/8W57RsBf+LZ1q29vDYBtbNTkucfq2dsmJNyxTiGu+0tHxKZIUQa1qiXzKmZRvw803L1o6/5dNj+EebNtGmZRsPj23gTkuczm2csmJNy6bENd5pafkc5dOy+f/JtMS2dntt4Xi4vUHj3Z6zXnFtoedFq9DG42CZLFKm+wSg5h5PU277EOfSPZyvriIy3r5tGZbv9h70zefNPfXU680Y53zi6xEdrXei5bvBdOgc8pfJes2508F3R7spt3uIc+keLtr2LZ7pEK0Xp2/b4dvPcLcdveKcDg3tJVoO06E0juUh2nRgy0PfOJeHvs50wPZxO28Enf/jcD4PdzvBlgf3SQGWHxjnet9dX1VG/g4n9Cmp11MW1/u+O3Vc/8oY/r5zBC1g3MwnVJuUcfOeI9jobgmoF8cxEKg/Dc3H3Tb59g18vYLzAvWXXbdHZ7Q7zH29mPDYzj028D1lINVTvtvDbec4piUrCzv72G2x7w7O//Ku6njaYHgD5ucMGDfzCdUmZdy88zPuO7nzc7y93+Jd59n2891V7T4p2ffk52jzbKzexNgjFvlDYkyvaD2f/2mvXHxilHV0OzwFAknvGBiOto+U7/Fx22yssz226yk855XnKcfysc61uU8xaeHUG+ucVzxPnwgEoq+jo61XfduCIPlp63H/59YTzdm3XGH7useQtr3YU9bcfQnLT4lznw7vbrDlp8RR/gzYp5vm7Hv5njpsuFNC/6zuPFL3CVD3MaTMYIwy3fmdta97TdDys+LcPvruJDF1nRTiXHoUDtsWt+1u2/ru6PTd7ZDjuNnvfT9tee7/3Pnfd7dKcvdd664NFsYYb3dfvQjGIda5AXfd5ivfPZfrO2bCMty7eX372ebjzn8XwDJwCVmHBwLxnT/2XQvw3aXvHtfNjnN728JTFnrnBuqPux0m1vJxeRzrlGjjYvkl0J5XOV7R7u72dWKPtv6w/LVQ3zynPva0BPwuEIhvm+dz93Wow3XJvFDjjOMtMI7zQxvXjccD+PSY+U7duXHWnev5zr0DzLePFG3bi/t4rqvbLsjfDeO90Jm2OHxaFHe3075v/yTJ+5Zxd/jFp4a5828j+pS42zbrg+1qPm6/on/rDlL0yYvik6RtYIW7DUQf3zoCO/z69lPY9gjrcDv8sqe+uNMo2nTz7Ue7T/Fq5qkHl7dodUY79sS7S3086x+zuAHnS3C9Z5+U7p5HtqzvZyAQ3/6Y75y0u9/nbleXOe3oOyeIw7p9Kiz/CawLlzvrQt8TjXOd4dHfLj/udYvKyN/hhD51y3Mrz7ji8sHOo7+h7PznRvuXUC+OYyBQ/3ym+bDr1sjjdHLPcfqupwedNsGyou2/+s63R7uD3/Ifxrn/6jvXH+v4zt0v9R1n+PoSJfnabr15HPeFWnt83Hl8tTNebSP/x+OtIk85lm/jqbctMO75hjZOvQ3p64E+7hO8fdcukWd9T9bG6ePrp4Tzvrs9sfyPsN783jkHgMsL9gFMSfPXHQj493fdJ6742gJ5dh133X/ZX6G0bp729Vfw9c1x560/Euiv4Nvuuj7IYxtYt2h9T3zTHK/z2mnuK6OA+OOyh7x7/dbymWl19aWn+cvMImW6129908OUm53GuXQP56vL7XPobh9wON8yHu86gfXbyYu4xdqeRLuG73PFdVY8ff9aRHG1fEEM15woZeH+YTL3W/pW1L3x1+4z2WXb/YTge+TbxhhPezPe+vGqrfs/7qOZT0bkb7vsuDyeA0G+GJadTjCPr2c99RkuHIULkp/ry/D8LxQZ1k4nfCtxY+9XmE9WbV07pDp1ok+Kw7u/pzn/6wnrHfPJrq0/3vhmZlunnbb41ufs2thlpXnKyvPwTZyyfG95xv/hTeqdI+OU5dTZyNOmBOcpM7/beSE9OfWVBp3xsfuG5hOq3dAUG+rPcdoSuf+X+daOyz+db4c6820TZzzwf1h+Q+dzXCfFM59jWU2csjISKCvaMpPRQC9fWelOWf9k+SuHZeJ/Iqv1Lk0sAgA=","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"70":{"source":"use std::runtime::is_unconstrained;\nuse std::hash::sha256_compression;\n\n/// Block size\nglobal BLOCK_SIZE: u32 = 64;\n\n/// First index in the block where the 8-byte message will be written.\nglobal MSG_LEN_PTR: u32 = 56;\n\n/// Size of message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n/// Size of unsigned 32 bit integer in bytes.\nglobal INT_SIZE: u32 = 4;\n\n/// Index of the integer in `INT_BLOCK` where the length is writen.\nglobal INT_SIZE_PTR: u32 = MSG_LEN_PTR / INT_SIZE;\n\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n/// Index of abyte in 64 byte block;\ntype BlockBytePtr = u32;\n\n/// Foreign function interface type\npub(crate) type IntBlock = [u32; INT_BLOCK_SIZE];\n\ntype MsgBlock = IntBlock;\n\ntype Hash = [u8; 32];\n\ntype State = [u32; 8];\n\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> Hash {\n    sha256_var(msg, N as u64)\n}\n\n/// SHA256 hash function\npub fn sha256_var<let N: u32>(msg: [u8; N], msg_len: u64) -> Hash {\n    let msg_len = msg_len as u32;\n\n    let num_blocks = N / BLOCK_SIZE;\n\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let mut state: State = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\n        0x5be0cd19,\n    ];\n\n    let mut msg_byte_ptr = 0;\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        if (msg_start < msg_len) & (msg_byte_ptr == BLOCK_SIZE) {\n            state = sha256_compression(msg_block, state);\n        }\n    }\n\n    let modulus = N % BLOCK_SIZE;\n\n    if modulus != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block(msg, msg_len, msg_start) };\n\n        if msg_start < msg_len {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, msg_len, msg_block, msg_start);\n\n            if msg_start < msg_len {\n                msg_byte_ptr = new_msg_byte_ptr;\n\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < msg_len {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n\n    msg_byte_ptr += 1;\n\n    let last_block = msg_block;\n\n    if msg_byte_ptr > MSG_LEN_PTR {\n        state = sha256_compression(msg_block, state);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, msg_len) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, msg_len);\n    }\n\n    hash_final_block(msg_block, state)\n}\n\nunconstrained pub(crate) fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_start: u32,\n) -> (MsgBlock, BlockBytePtr) {\n    let mut msg_block: MsgBlock = [0; INT_BLOCK_SIZE];\n\n    let block_input = if msg_start + BLOCK_SIZE > msg_len {\n        if msg_len < msg_start {\n            0\n        } else {\n            msg_len - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    let mut int_input = block_input / INT_SIZE;\n\n    if block_input % INT_SIZE != 0 {\n        int_input += 1;\n    }\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n\n            msg_item = shl8(msg_item, 1) + msg_byte as u32;\n        }\n\n        msg_block[i] = msg_item;\n    }\n\n    (msg_block, block_input)\n}\n\npub(crate) fn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    msg_len: u32,\n    msg_block: MsgBlock,\n    msg_start: u32,\n) -> BlockBytePtr {\n    let mut msg_byte_ptr = 0;\n\n    let mut msg_end = msg_start + BLOCK_SIZE;\n\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    if msg_end % INT_SIZE != 0 {\n        msg_end += INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    let mut msg_item: u32 = 0;\n\n    let mut i: u32 = 0;\n\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            if (msg_start < msg_len) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n\n                i += 1;\n\n                msg_item = 0;\n            }\n        }\n\n        msg_item = shl8(msg_item, 1);\n\n        if k < msg_len & k < msg_end {\n            msg_item += msg[k] as u32;\n\n            msg_byte_ptr += 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\npub(crate) fn verify_msg_block_padding(msg_block: MsgBlock, msg_byte_ptr: BlockBytePtr) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\npub(crate) fn verify_msg_block_zeros(\n    msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    max_int_byte_ptr: u32,\n) {\n    let zero = msg_block[0] - msg_block[0];\n\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let zeros = INT_SIZE - modulus;\n\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n\n        int_byte_ptr += 1;\n    }\n\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\npub(crate) fn verify_msg_block_equals_last(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n) {\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let last_field = last_block[int_byte_ptr];\n\n        let mut msg_item: u32 = 0;\n\n        msg_byte_ptr -= modulus;\n\n        for i in 0..INT_SIZE {\n            msg_item = shl8(msg_item, 1);\n\n            if i < modulus {\n                msg_item += get_item_byte(last_field, msg_byte_ptr) as u32;\n\n                msg_byte_ptr += 1;\n            }\n        }\n\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\npub(crate) fn update_block_item<Env>(\n    mut msg_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    f: fn[Env](u32) -> u32,\n) -> MsgBlock {\n    let i = msg_byte_ptr / INT_SIZE;\n\n    msg_block[i] = f(msg_block[i]);\n\n    msg_block\n}\n\npub(crate) fn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BlockBytePtr, msg_byte: u8) -> u32 {\n    let zeros = (INT_SIZE - msg_byte_ptr % INT_SIZE) as u8;\n\n    let zeroed_item = shl8(shr8(msg_item, zeros), zeros);\n\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n\n    zeroed_item + new_item\n}\n\npub(crate) fn get_item_byte(mut msg_item: u32, msg_byte_ptr: BlockBytePtr) -> u8 {\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    msg_item = shr8(msg_item, shifts);\n\n    msg_item as u8\n}\n\npub(crate) fn byte_into_item(msg_byte: u8, msg_byte_ptr: BlockBytePtr) -> u32 {\n    let mut msg_item = msg_byte as u32;\n\n    let max_shifts = INT_SIZE - 1;\n\n    let shifts = (max_shifts - msg_byte_ptr % INT_SIZE) as u8;\n\n    shl8(msg_item, shifts)\n}\n\npub(crate) fn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = shl8(item, 1) + b1 as u32;\n    item = shl8(item, 1) + b2 as u32;\n    item = shl8(item, 1) + b3 as u32;\n\n    item\n}\n\npub(crate) fn shl8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\npub(crate) fn shr8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\nunconstrained pub(crate) fn attach_len_to_msg_block(\n    mut msg_block: MsgBlock,\n    mut msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) -> MsgBlock {\n    let modulus = msg_byte_ptr % INT_SIZE;\n\n    if modulus != 0 {\n        let i = msg_byte_ptr / INT_SIZE;\n\n        let zeros = (INT_SIZE - modulus) as u8;\n\n        msg_block[i] = shl8(shr8(msg_block[i], zeros), zeros);\n\n        msg_byte_ptr += zeros as u32;\n    }\n\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * msg_len;\n\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n\n    for i in 0..=1 {\n        let shift = i * 4;\n\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n\n    msg_block\n}\n\npub(crate) fn verify_msg_len(\n    msg_block: MsgBlock,\n    last_block: MsgBlock,\n    msg_byte_ptr: BlockBytePtr,\n    msg_len: u32,\n) {\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    let mut reconstructed_len: u64 = 0;\n\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len *= TWO_POW_32;\n\n        reconstructed_len += msg_block[i] as u64;\n    }\n\n    let len = 8 * msg_len as u64;\n\n    assert_eq(reconstructed_len, len);\n}\n\npub(crate) fn hash_final_block(msg_block: MsgBlock, mut state: State) -> Hash {\n    let mut out_state: Hash = [0; 32];\n\n    state = sha256_compression(msg_block, state);\n\n    for j in 0..8 {\n        let state_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n\n        for k in 0..4 {\n            out_state[4 * j + k] = state_bytes[k];\n        }\n    }\n\n    out_state\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/sha256.nr"},"71":{"source":"use crate::sha256::{\n    attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n    set_item_byte_then_zeros, sha256_var, IntBlock, shl8, shr8,\n};\n\n#[test]\n#[export]\nfn test_sha256_0() -> [u8; 32] {\n    sha256_var([], 0)\n}\n\n#[test]\n#[export]\nfn test_sha256_1(input: [u8; 1], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_200(input: [u8; 200], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_511(input: [u8; 511], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\n#[export]\nfn test_sha256_512(input: [u8; 512], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\nfn test_smoke() {\n    let input = [0xbd];\n\n    let result = [\n        0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05,\n        0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe,\n        0x73, 0x2b,\n    ];\n\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    let result = [\n        91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24,\n        65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_multiple_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n    ];\n    let result = [\n        116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60,\n        47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_under_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59,\n    ];\n    let result = [\n        143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165,\n        74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_not_block_multiple() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115,\n        97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n    ];\n    let result = [\n        112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55,\n        192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_with_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    let message_size = 297;\n    assert_eq(sha256_var(input, message_size), result);\n}\n\n#[test]\nfn msg_big_no_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn test_get_item_byte() {\n    let fld = make_item(10, 20, 30, 40);\n    assert_eq(fld, 0x0a141e28);\n    assert_eq(get_item_byte(fld, 0), 10);\n    assert_eq(get_item_byte(fld, 4), 10);\n    assert_eq(get_item_byte(fld, 6), 30);\n}\n\n#[test]\nfn test_byte_into_item() {\n    let fld = make_item(0, 20, 0, 0);\n    assert_eq(byte_into_item(20, 1), fld);\n    assert_eq(byte_into_item(20, 5), fld);\n}\n\n#[test]\nfn test_set_item_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 0, 0, 0);\n    assert_eq(shl8(shr8(fld0, 3), 3), fld1);\n    assert_eq(shl8(shr8(fld0, 4), 4), 0);\n    assert_eq(shl8(shr8(0, 4), 4), 0);\n}\n\n#[test]\nfn test_set_item_byte_then_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 50, 0, 0);\n    assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n}\n\n#[test]\nfn test_build_msg_block_start_0() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48,\n    ];\n    assert_eq(input.len(), 22);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n    assert_eq(msg_byte_ptr, input.len());\n    assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n    assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n    assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n    assert_eq(msg_block[6], 0);\n}\n\n#[test]\nfn test_build_msg_block_start_1() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    assert_eq(input.len(), 68);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n    assert_eq(msg_byte_ptr, 4);\n    assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n    assert_eq(msg_block[1], 0);\n}\n\n#[test]\nfn test_attach_len_to_msg_block() {\n    let input: IntBlock = [\n        2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n        1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n        1849316213, 1651139939,\n    ];\n    let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n    assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n    assert_eq(msg_block[1], 0);\n    assert_eq(msg_block[15], 3584);\n}\n","path":"/home/jtriley/docs/zk/nr/sha256/src/tests.nr"}},"names":["test_sha256_512"],"brillig_names":["test_sha256_512"]}