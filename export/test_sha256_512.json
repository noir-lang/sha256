{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":2294856068790126886,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":512,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"71":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n","path":"/Users/joshuatrujillo/Documents/github/zk/noir/sha256/src/sha256.nr"},"72":{"source":"use crate::sha256::{\n    attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n    set_item_byte_then_zeros, sha256_var, sha256, set_item_zeros, INT_BLOCK,\n};\n\n#[export]\nfn test_sha256_0() -> [u8; 32] {\n    sha256_var([], 0)\n}\n\n#[export]\nfn test_sha256_1(input: [u8; 1], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[export]\nfn test_sha256_200(input: [u8; 200], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[export]\nfn test_sha256_511(input: [u8; 511], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[export]\nfn test_sha256_512(input: [u8; 512], len: u64) -> [u8; 32] {\n    sha256_var(input, len)\n}\n\n#[test]\nfn smoke_test() {\n    let input = [0xbd];\n    let result = [\n        0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05,\n        0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe,\n        0x73, 0x2b,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    let result = [\n        91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24,\n        65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_multiple_over_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n    ];\n    let result = [\n        116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60,\n        47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_just_under_block() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59,\n    ];\n    let result = [\n        143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165,\n        74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_not_block_multiple() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13,\n        10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77,\n        97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55,\n        51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116,\n        58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60,\n        56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70,\n        45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13,\n        10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50,\n        51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122,\n        107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10,\n        100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32,\n        97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120,\n        101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117,\n        100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54,\n        57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86,\n        85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110,\n        117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111,\n        109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45,\n        86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115,\n        97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n    ];\n    let result = [\n        112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55,\n        192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn msg_big_with_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    let message_size = 297;\n    assert_eq(sha256_var(input, message_size), result);\n}\n\n#[test]\nfn msg_big_no_padding() {\n    let input = [\n        48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48,\n        37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201,\n        130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1,\n        2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141,\n        128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0,\n        194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36,\n        21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87,\n        144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30,\n        183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11,\n        114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6,\n        121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41,\n        138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222,\n        89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166,\n        103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n    ];\n    let result = [\n        32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n        181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n    ];\n    assert_eq(sha256_var(input, input.len() as u64), result);\n}\n\n#[test]\nfn same_msg_len_variable_padding() {\n    let input = [\n        29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179,\n        218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53,\n        32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178,\n        186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113,\n        247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175,\n        120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44,\n        12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98,\n        90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146,\n        145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118,\n        4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246,\n        67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25,\n        48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213,\n        196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81,\n        125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113,\n        81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50,\n        50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130,\n        89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188,\n        50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29,\n        255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228,\n        175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n        101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157,\n        167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30,\n        63, 129, 143, 32, 96,\n    ];\n\n    // Prepare inputs of different lengths\n    let mut input_511 = [0; 511];\n    let mut input_512 = [0; 512]; // Next block\n    let mut input_575 = [0; 575];\n    let mut input_576 = [0; 576]; // Next block\n    for i in 0..input.len() {\n        input_511[i] = input[i];\n        input_512[i] = input[i];\n        input_575[i] = input[i];\n        input_576[i] = input[i];\n    }\n\n    // Compute hashes of all inputs (with same message length)\n    let fixed_length_hash = sha256(input);\n    let var_full_length_hash = sha256_var(input, input.len() as u64);\n    let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n    let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n    let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n    let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n    // All of the above should have produced the same hash\n    assert_eq(var_full_length_hash, fixed_length_hash);\n    assert_eq(var_length_hash_511, fixed_length_hash);\n    assert_eq(var_length_hash_512, fixed_length_hash);\n    assert_eq(var_length_hash_575, fixed_length_hash);\n    assert_eq(var_length_hash_576, fixed_length_hash);\n}\n\n#[test]\nfn test_get_item_byte() {\n    let fld = make_item(10, 20, 30, 40);\n    assert_eq(fld, 0x0a141e28);\n    assert_eq(get_item_byte(fld, 0), 10);\n    assert_eq(get_item_byte(fld, 4), 10);\n    assert_eq(get_item_byte(fld, 6), 30);\n}\n\n#[test]\nfn test_byte_into_item() {\n    let fld = make_item(0, 20, 0, 0);\n    assert_eq(byte_into_item(20, 1), fld);\n    assert_eq(byte_into_item(20, 5), fld);\n}\n\n#[test]\nfn test_set_item_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 0, 0, 0);\n    assert_eq(set_item_zeros(fld0, 3), fld1);\n    assert_eq(set_item_zeros(fld0, 4), 0);\n    assert_eq(set_item_zeros(0, 4), 0);\n}\n\n#[test]\nfn test_set_item_byte_then_zeros() {\n    let fld0 = make_item(10, 20, 30, 40);\n    let fld1 = make_item(10, 50, 0, 0);\n    assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n}\n\n#[test]\nfn test_build_msg_block_start_0() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48,\n    ];\n    assert_eq(input.len(), 22);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n    assert_eq(msg_byte_ptr, input.len());\n    assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n    assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n    assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n    assert_eq(msg_block[6], 0);\n}\n\n#[test]\nfn test_build_msg_block_start_1() {\n    let input = [\n        102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101,\n        115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110,\n        116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105,\n        110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n    ];\n    assert_eq(input.len(), 68);\n    let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n    assert_eq(msg_byte_ptr, 4);\n    assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n    assert_eq(msg_block[1], 0);\n}\n\n#[test]\nfn test_attach_len_to_msg_block() {\n    let input: INT_BLOCK = [\n        2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n        1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n        1849316213, 1651139939,\n    ];\n    let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n    assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n    assert_eq(msg_block[1], 0);\n    assert_eq(msg_block[15], 3584);\n}\n","path":"/Users/joshuatrujillo/Documents/github/zk/noir/sha256/src/tests.nr"}},"names":["test_sha256_512"],"brillig_names":["test_sha256_512"]}